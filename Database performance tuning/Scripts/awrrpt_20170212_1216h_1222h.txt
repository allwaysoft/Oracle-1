Introduction
AWR periodically gathers and stores system activity and workload data which is then analyzed by ADDM. Every layer of Oracle is equipped with instrumentation that gathers information on workload which will then be used to make self-managing decisions. AWR is the place where this data is stored. AWR looks periodically at the system performance (by default every 60 minutes) and stores the information found (by default up to 7 days). AWR runs by default and Oracle states that it does not add a noticeable level of overhead. A new background server process (MMON) takes snapshots of the in-memory database statistics (much like STATSPACK) and stores this information in the repository. MMON also provides Oracle with a server initiated alert feature, which notifies database administrators of potential problems (out of space, max extents reached, performance thresholds, etc.). The information is stored in the SYSAUX tablespace. This information is the basis for all self-management decisions.

To access Automatic Workload Repository through Oracle Enterprise Manager Database Control:
    On the Administration page, select the Workload Repository link under Workload. From the Automatic Workload Repository page, you can manage snapshots or modify AWR settings.
          o To manage snapshots, click the link next to Snapshots or Preserved Snapshot Sets. On the Snapshots or Preserved Snapshot Sets pages, you can:
                + View information about snapshots or preserved snapshot sets (baselines).
                + Perform a variety of tasks through the pull-down Actions menu, including creating additional snapshots, preserved snapshot sets from an existing range of snapshots, or an ADDM task to perform analysis on a range of snapshots or a set of preserved snapshots.
          o To modify AWR settings, click the Edit button. On the Edit Settings page, you can set the Snapshot Retention period and Snapshot Collection interval.


Most informative sections of the report
I find the following sections most useful:
- Summary
- Top 5 timed events
- Top SQL (by elapsed time, by gets, sometimes by reads)

When viewing AWR report, always check corresponding ADDM report for actionable recommendations. ADDM is a self diagnostic engine designed from the experience of Oracle’s best tuning experts. Analyzes AWR data automatically after an AWR snapshot. Makes specific performance recommendations.


Both the snapshot frequency and retention time can be modified by the user. To see the present settings, you could use:
select snap_interval, retention from dba_hist_wr_control;

SNAP_INTERVAL       RETENTION
------------------- -------------------
+00000 01:00:00.0   +00007 00:00:00.0

or
select dbms_stats.get_stats_history_availability from dual;
select dbms_stats.get_stats_history_retention from dual;

This SQL shows that the snapshots are taken every hour and the collections are retained for 7 days

If you want to extend that retention period you can execute:
execute dbms_workload_repository.modify_snapshot_settings(
      interval => 60,        -- In Minutes. Current value retained if NULL.
      retention => 43200);   -- In Minutes (= 30 Days). Current value retained if NULL

In this example the retention period is specified as 30 days (43200 min) and the interval between each snapshot is 60 min.


Differences between AWR and STATSPACK report
1)Statspack snapshot purges must be scheduled manually. When the Statspack tablespace runs out of space, Statspack quits working. AWR snapshots are purged automatically by MMON every night. MMON, by default, tries to keep one week's worth of AWR snapshots available. If AWR detects that the SYSAUX tablespace is in danger of running out of space, it will free space in SYSAUX by automatically deleting the oldest set of snapshots. If this occurs, AWR will initiate a server-generated alert to notify administrators of the out-of-space error condition.

2)The AWR repository holds all of the statistics available in STATSPACK as well as some additional statistics which are not.

3)STATSPACK does not store the Active Session History (ASH) statistics which are available in the AWR dba_hist_active_sess_history view.

4)STATSPACK does not store history for new metric statistics introduced in Oracle. The key AWR views are: dba_hist_sysmetric_history and dba_hist_sysmetric_summary.

5)The AWR also contains views such as dba_hist_service_stat , dba_hist_service_wait_class and dba_hist_service_name , which store history for performance cumulative statistics tracked for specific services.

6)The latest version of STATSPACK included with Oracle contains a set of specific tables, which track history of statistics that reflect the performance of the Oracle Streams feature. These tables are stats$streams_capture , stats$streams_apply_sum , stats$buffered_subscribers , stats$rule_set , stats$propagation_sender , stats$propagation_receiver and stats$buffered_queues . The AWR does not contain the specific tables that reflect Oracle Streams activity; therefore, if a DBA relies heavily on the Oracle Streams feature, it would be useful to monitor its performance using STATSPACK utility.

7)Statspack snapshots must be run by an external scheduler (dbms_jobs, CRON, etc.). AWR snapshots are scheduled every 60 minutes by default.

8)ADDM captures a much greater depth and breadth of statistics than Statspack does. During snapshot processing, MMON transfers an in-memory version of the statistics to the permanent statistics tables.


Workload Repository Reports
Oracle provide two main scripts to produce workload repository reports. They are similar in format to the statspack reports and give the option of HTML or plain text formats. The two reports give essential the same output but the awrrpti.sql allows you to select a single instance. The reports can be generated as follows:
    @$ORACLE_HOME/rdbms/admin/awrrpt.sql
    @$ORACLE_HOME/rdbms/admin/awrrpti.sql

There are other scripts too, here is the full list:

REPORT NAME 	SQL Script
Automatic Workload Repository Report 	awrrpt.sql
Automatic Database Diagnostics Monitor Report 	addmrpt.sql
ASH Report 	ashrpt.sql
AWR Diff Periods Report 	awrddrpt.sql
AWR Single SQL Statement Report 	awrsqrpt.sql
AWR Global Report 	awrgrpt.sql
AWR Global Diff Report 	awrgdrpt.sql
  

The scripts prompt you to enter the report format (html or text), the start snapshot id, the end snapshot id and the report filename. This script looks like Statspack; it shows all the AWR snapshots available and asks for two specific ones as interval boundaries.


AWR Snapshots and Baselines
You can create a snapshot manually using:
EXEC dbms_workload_repository.create_snapshot;

You can see what snapshots are currently in the AWR by using the DBA_HIST_SNAPSHOT view as seen in this example:

SELECT snap_id, to_char(begin_interval_time,'dd/MON/yy hh24:mi') Begin_Interval,
       to_char(end_interval_time,'dd/MON/yy hh24:mi') End_Interval
FROM dba_hist_snapshot
ORDER BY 1;

   SNAP_ID BEGIN_INTERVAL  END_INTERVAL
---------- --------------- ---------------
       954 30/NOV/05 03:01 30/NOV/05 04:00
       955 30/NOV/05 04:00 30/NOV/05 05:00
       956 30/NOV/05 05:00 30/NOV/05 06:00
       957 30/NOV/05 06:00 30/NOV/05 07:00
       958 30/NOV/05 07:00 30/NOV/05 08:00
       959 30/NOV/05 08:00 30/NOV/05 09:00

Each snapshot is assigned a unique snapshot ID that is reflected in the SNAP_ID column. The END_INTERVAL_TIME column displays the time that the actual snapshot was taken.

Sometimes you might want to drop snapshots manually. The dbms_workload_repository.drop_snapshot_range procedure can be used to remove a range of snapshots from the AWR. This procedure takes two parameters, low_snap_id and high_snap_id, as seen in this example:

EXEC dbms_workload_repository.drop_snapshot_range(low_snap_id=>1107, high_snap_id=>1108);

The following workload repository views are available:
    * V$ACTIVE_SESSION_HISTORY - Displays the active session history (ASH) sampled every second.
    * V$METRIC - Displays metric information.
    * V$METRICNAME - Displays the metrics associated with each metric group.
    * V$METRIC_HISTORY - Displays historical metrics.
    * V$METRICGROUP - Displays all metrics groups.
    * DBA_HIST_ACTIVE_SESS_HISTORY - Displays the history contents of the active session history.
    * DBA_HIST_BASELINE - Displays baseline information.
    * DBA_HIST_DATABASE_INSTANCE - Displays database environment information.
    * DBA_HIST_SNAPSHOT - Displays snapshot information.
    * DBA_HIST_SQL_PLAN - Displays SQL execution plans.
    * DBA_HIST_WR_CONTROL - Displays AWR settings.

Finally , you can use the following query to identify the occupants of the SYSAUX Tablespace

select substr(occupant_name,1,40), space_usage_kbytes
   from v$sysaux_occupants;


AWR Automated Snapshots

Oracle uses a scheduled job, GATHER_STATS_JOB, to collect AWR statistics. This job is created, and enabled automatically, when you create a new Oracle database. To see this job, use the DBA_SCHEDULER_JOBS view as seen in this example:

SELECT a.job_name, a.enabled, c.window_name, c.schedule_name, c.start_date, c.repeat_interval
FROM dba_scheduler_jobs a, dba_scheduler_wingroup_members b, dba_scheduler_windows c
WHERE job_name='GATHER_STATS_JOB'
  And a.schedule_name=b.window_group_name
  And b.window_name=c.window_name;

You can disable this job using the dbms_scheduler.disable procedure as seen in this example:
Exec dbms_scheduler.disable('GATHER_STATS_JOB');

And you can enable the job using the dbms_scheduler.enable procedure as seen in this example:
Exec dbms_scheduler.enable('GATHER_STATS_JOB');

AWR Baselines
It is frequently a good idea to create a baseline in the AWR. A baseline is defined as a range of snapshots that can be used to compare to other pairs of snapshots. The Oracle database server will exempt the snapshots assigned to a specific baseline from the automated purge routine. Thus, the main purpose of a baseline is to preserve typical runtime statistics in the AWR repository, allowing you to run the AWR snapshot reports on the preserved baseline snapshots at any time and compare them to recent snapshots contained in the AWR. This allows you to compare current performance (and configuration) to established baseline performance, which can assist in determining database performance problems.

Creating baselines
You can use the create_baseline procedure contained in the dbms_workload_repository stored PL/SQL package to create a baseline as seen in this example:
EXEC dbms_workload_repository.create_baseline (start_snap_id=>1109, end_snap_id=>1111, baseline_name=>'EOM Baseline');

Baselines can be seen using the DBA_HIST_BASELINE view as seen in the following example:
SELECT baseline_id, baseline_name, start_snap_id, end_snap_id
FROM dba_hist_baseline;

BASELINE_ID BASELINE_NAME   START_SNAP_ID END_SNAP_ID
----------- --------------- ------------- -----------
          1 EOM Baseline             1109        1111

In this case, the column BASELINE_ID identifies each individual baseline that has been defined. The name assigned to the baseline is listed, as are the beginning and ending snapshot IDs.

Removing baselines
The pair of snapshots associated with a baseline are retained until the baseline is explicitly deleted. You can remove a baseline using the dbms_workload_repository.drop_baseline procedure as seen in this example that drops the “EOM Baseline” that we just created.
EXEC dbms_workload_repository.drop_baseline (baseline_name=>'EOM Baseline', Cascade=>FALSE);

Note that the cascade parameter will cause all associated snapshots to be removed if it is set to TRUE; otherwise, the snapshots will be cleaned up automatically by the AWR automated processes.




Quick Summary on AWR Sections
This section contains detailed guidance for evaluating each section of an AWR report.
Report Summary Section:
This gives an overall summary of the instance during the snapshot period, and it contains important aggregate summary information.
- Cache Sizes: This shows the size of each SGA region after AMM has changed them.  This information can be compared to the original init.ora parameters at the end of the AWR report.
- Load Profile: This section shows important rates expressed in units of per second and transactions per second.
- Instance Efficiency Percentages: With a target of 100%, these are high-level ratios for activity in the SGA.
- Shared Pool Statistics: This is a good summary of changes to the shared pool during the snapshot period.
- Top 5 Timed Events: This is the most important section in the AWR report.  It shows the top wait events and can quickly show the overall database bottleneck.

Wait Events Statistics Section
This section shows a breakdown of the main wait events in the database including foreground and background database wait events as well as time model, operating system, service, and wait classes statistics.
- Time Model Statistics: Time mode statistics report how database-processing time is spent. This section contains detailed timing information on particular components participating in database processing.
- Wait Class: 
- Wait Events: This AWR report section provides more detailed wait event information for foreground user processes which includes Top 5 wait events and many other wait events that occurred during the snapshot interval.
- Background Wait Events: This section is relevant to the background process wait events.
- Operating System Statistics: The stress on the Oracle server is important, and this section shows the main external resources including I/O, CPU, memory, and network usage.
- Service Statistics: The service statistics section gives information about how particular services configured in the database are operating.
- Service Wait Class Stats: 

SQL Statistics Section
This section displays top SQL, ordered by important SQL execution metrics.
- SQL Ordered by Elapsed Time: Includes SQL statements that took significant execution time during processing.
- SQL Ordered by CPU Time: Includes SQL statements that consumed significant CPU time during its processing.
- SQL Ordered by Gets: These SQLs performed a high number of logical reads while retrieving data.
- SQL Ordered by Reads: These SQLs performed a high number of physical disk reads while retrieving data.
- SQL Ordered by Executions: 
- SQL Ordered by Parse Calls: These SQLs experienced a high number of reparsing operations.
- SQL Ordered by Sharable Memory: Includes SQL statements cursors which consumed a large amount of SGA shared pool memory.
- SQL Ordered by Version Count: These SQLs have a large number of versions in shared pool for some reason.
- Complete List of SQL Text: 

Instance Activity Stats
This section contains statistical information describing how the database operated during the snapshot period.
- Instance Activity Stats - Absolute Values: This section contains statistics that have absolute values not derived from end and start snapshots.
- Instance Activity Stats - Thread Activity: This report section reports a log switch activity statistic.

I/O Stats Section
This section shows the all important I/O activity for the instance and shows I/O activity by tablespace, data file, and includes buffer pool statistics.
- Tablespace IO Stats 
- File IO Stats 

Buffer Pool Statistics Section

Advisory Statistics Section
This section show details of the advisories for the buffer, shared pool, PGA and Java pool.
- Instance Recovery Stats: 
- Buffer Pool Advisory: 
- PGA Aggr Summary: PGA Aggr Target Stats; PGA Aggr Target Histogram; and PGA Memory Advisory. 
- Shared Pool Advisory: 
- SGA Target Advisory
- Stream Spool Advisory
- Java Pool Advisory 

Wait Statistics Section
- Buffer Wait Statistics: This important section shows buffer cache waits statistics.
- Enqueue Activity: This important section shows how enqueue operates in the database. Enqueues are special internal structures which provide concurrent access to various database resources.

Undo Statistics Section
- Undo Segment Summary: This section gives a summary about how undo segments are used by the database.
- Undo Segment Stats: This section shows detailed history information about undo segment activity.

Latch Statistics Section:
This section shows details about latch statistics. Latches are a lightweight serialization mechanism that is used to single-thread access to internal Oracle structures.
- Latch Activity
- Latch Sleep Breakdown
- Latch Miss Sources
- Parent Latch Statistics
- Child Latch Statistics

Segment Statistics Section:
This report section provides details about hot segments using the following criteria:
- Segments by Logical Reads: Includes top segments which experienced high number of logical reads.
- Segments by Physical Reads: Includes top segments which experienced high number of disk physical reads.
- Segments by Row Lock Waits: Includes segments that had a large number of row locks on their data.
- Segments by ITL Waits: Includes segments that had a large contention for Interested Transaction List (ITL). The contention for ITL can be reduced by increasing INITRANS storage parameter of the table.
- Segments by Buffer Busy Waits: These segments have the largest number of buffer waits caused by their data blocks.

Dictionary Cache Stats Section
This section exposes details about how the data dictionary cache is operating.

Library Cache Section
Includes library cache statistics describing how shared library objects are managed by Oracle.

Memory Statistics Section
- Process Memory Summary
- SGA Memory Summary: This section provides summary information about various SGA regions.
- SGA Breakdown difference: 

Streams Statistics Section
- Streams CPU/IO Usage
- Streams Capture
- Streams Apply
- Buffered Queues
- Buffered Subscribers
- Rule Set

-- Inicio
The main sections in an AWR report include:

AWR Report Header:
This section shows basic information about the report like when the snapshot was taken, for how long, Cache Sizes at the beginning and end of the Snapshot, etc.

WORKLOAD REPOSITORY report for

DB Name         DB Id    Instance     Inst Num Startup Time    Release     RAC
------------ ----------- ------------ -------- --------------- ----------- ---
ORCL          1344731332 orcl                1 12-Feb-17 08:19 11.2.0.1.0  NO

Host Name        Platform                         CPUs Cores Sockets Memory(GB)
---------------- -------------------------------- ---- ----- ------- ----------
fabioprado.net   Linux x86 64-bit                    2     2       1       1.96

              Snap Id      Snap Time      Sessions Curs/Sess
            --------- ------------------- -------- ---------
Begin Snap:        37 12-Feb-17 12:16:04        25       1.6
  End Snap:        38 12-Feb-17 12:22:06        27       2.1
   Elapsed:                6.03 (mins)
   DB Time:              141.41 (mins)

Cache Sizes                       Begin        End
~~~~~~~~~~~                  ---------- ----------
               Buffer Cache:       424M       424M  Std Block Size:         8K
           Shared Pool Size:       212M       212M      Log Buffer:     5,424K

Elasped Time: It represents the snapshot window or the time between the two snapshots.
DB TIME: Represents the activity on the database.

If DB TIME is Greater than Elapsed Time then it means that database has high workload.

Load Profile:
The load profile provides an at-a-glance look at some specific operational statistics. You can compare these statistics with a baseline snapshot report to determine if database activity is different. Values for these statistics are presented in two formats. The first is the value per second (for example, how much redo was generated per second) and the second is the value per transaction (for example, 1,024 bytes of redo were generated per transaction).

Load Profile              Per Second    Per Transaction   Per Exec   Per Call
~~~~~~~~~~~~         ---------------    --------------- ---------- ----------
      DB Time(s):               23.5                0.9       0.09       0.68
       DB CPU(s):                0.1                0.0       0.00       0.00
       Redo size:           56,890.1            2,287.8
   Logical reads:            2,021.9               81.3
   Block changes:              405.1               16.3
  Physical reads:              130.9                5.3
 Physical writes:               40.7                1.6
      User calls:               34.7                1.4
          Parses:               49.3                2.0
     Hard parses:                0.9                0.0
W/A MB processed:                0.2                0.0
          Logons:                0.3                0.0
        Executes:              256.5               10.3
       Rollbacks:                0.0                0.0
    Transactions:               24.9
Where:

DB time(s): It's the amount of time oracle has spent performing database user calls. Note it does not include background processes.
DB CPU(s): It's the amount of CPU time spent on user calls. As DB time, it does not include background process. The value is in microseconds
Redo size: This is the amount of DML happening in the DB. If you see an increase here then more DML statements are taking place (meaning your users are doing more INSERTs, UPDATEs, and DELETEs than before). For example, the table below shows that an average transaction generates about 12,000 of redo data along with around 26,000 redo per second.
Logical reads: This is calculated as Consistent Gets + DB Block Gets =  Logical Reads
Block Changes: The number of blocks modified during the sample interval. If you see an increase here then more DML statements are taking place (meaning your users are doing more INSERTs, UPDATEs, and DELETEs than before).
Physical reads: The number of requests for a block that caused a physical I/O.
Physical writes: Number of physical writes performed
User calls: Indicates how many user calls have occurred during the snapshot period. This value can give you some indication if usage has increased.
Parses: The total of all parses; both hard and soft.
Hard Parses: Those parses requiring a completely new parse of the SQL statement.  A ‘hard parse’ rate of greater than 100 per second indicates there is a very high amount of hard parsing on the system. High hard parse rates cause serious performance issues, and must be investigated. A high hard parse rate is usually accompanied by latch contention on the shared pool and library cache latches. Check whether waits for ‘latch free’ appear in the top-5 wait events, and if so, examine the latching sections of the report. Of course, we want a low number here. Possible reasons for excessive hard parses may be a small shared pool or may be that bind variables are not being used.
Soft Parses: Not listed but derived by subtracting the hard parses from parses.  A soft parse reuses a previous hard parse and hence consumes far fewer resources. A high soft parse rate could be anywhere in the rate of 300 or more per second. Unnecessary soft parses also limit application scalability; optimally a SQL statement should be soft-parsed once per session, and executed many times.
Sorts: Number of sorts occurring in the database
Logons: No of logons during the interval
Executes: how many statements we are executing per second / transaction
Transactions: How many transactions per second we process

The per-second statistics show you the changes in throughput (i.e. whether the instance is performing more work per second). For example:
• a significant increase in ‘redo size’, ‘block changes’ and ‘pct of blocks changed per read’ would indicate the instance is performing more inserts/updates/deletes.
• an increase in the ‘redo size’ without an increase in the number of ‘transactions per second’ would indicate a changing transaction profile.
Similarly, looking at the per-transaction statistics allows you to identify changes in the application characteristics by comparing these to the corresponding statistics from the baseline report.
Additionally, the load profile section provides the percentage of blocks that were changed per read, the percentage of recursive calls that occurred, the percentage of transactions that were rolled back and the number of rows sorted per sort operation.

In this example
• Comparing the number of Physical reads per second to the number of Physical writes per second shows the physical read to physical write ratio is very high. Typical OLTP systems have a read-to-write ratio of 10:1 or 5:1
• This system is busy, with 84 User calls per second.


Instance Efficiency Percentages (Target 100%)
These statistics include several buffer related ratios including the buffer hit percentage and the library hit percentage. Also, shared pool memory usage statistics are included in this section.

Instance Efficiency Percentages (Target 100%)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            Buffer Nowait %:   99.99       Redo NoWait %:  100.00
            Buffer  Hit   %:   93.53    In-memory Sort %:  100.00
            Library Hit   %:   99.25        Soft Parse %:   98.16
         Execute to Parse %:   80.77         Latch Hit %:   99.96
Parse CPU to Parse Elapsd %:    2.06     % Non-Parse CPU:   98.37

 Shared Pool Statistics        Begin    End
                              ------  ------
             Memory Usage %:   84.48   87.07
    % SQL with executions>1:   84.70   80.36
  % Memory for SQL w/exec>1:   85.53   74.24

Buffer Nowait Ratio. This is the percentage of time that the instance made a call to get a buffer (all buffer types are included here) and that buffer was made available immediately (meaning it didn't have to wait for the buffer...hence "Buffer Nowait"). If the ratio is low, then could be a (hot) block(s) being contended for that should be found in the Buffer Wait Section.. If the ratio is low, check the Buffer Wait Statistics section of the report for more detail on which type of block is being contended for.
Buffer Hit Ratio. (also known as the buffer-cache hit ratio) Ideally more than 95 percent. It shows the % of times a particular block was found in buffer cache insted of performing a physical I/O (reading from disk).
Although historically known as one of the most important statistics to evaluate, this ratio can sometimes be misleading. A low buffer hit ratio does not necessarily mean the cache is too small; it may be that potentially valid full-table scans are artificially reducing what is otherwise a good ratio. Similarly, a high buffer hit ratio (say, 99 percent) normally indicates that the cache is adequately sized, but this assumption may not always be valid. For example, frequently executed SQL statements that repeatedly refer to a small number of buffers via indexed lookups can create a misleadingly high buffer hit ratio. When these buffers are read, they are placed at the most recently used (MRU) end of the buffer cache; iterative access to these buffers can artificially inflate the buffer hit ratio. This inflation makes tuning the buffer cache a challenge. Sometimes you can identify a too-small buffer cache by the appearance of the write complete waits event, which indicates that hot blocks (that is, blocks that are still being modified) are aging out of the cache while they are still needed; check the Wait Events list for evidence of this event. If the number is negative, the BUFFER_CACHE is too small and the data is bein aged out before it can be used.
Library Hit Ratio. This ratio, also known as the library-cache hit ratio, gives the percentage of pin requests that result in pin hits. A pin hit occurs when the SQL or PL/SQL code to be executed is already in the library cache and is valid to execute. If the "Library Hit ratio" is low, it could be indicative of a shared pool that is too small (SQL is prematurely pushed out of the shared pool), or just as likely, that the system did not make correct use of bind variables in the application. If the soft parse ratio is also low, check whether there's a parsing issue. A lower ratio could also indicate that bind variables are not used or some other issue is causing SQL not to be reused (in which case a smaller shared pool may only be a band-aid that will potentially fix a library latch problem which may result).
Execute to Parse. If value is negative, it means that the number of parses is larger than the number of executions. Another cause for a negative execute to parse ratio is if the shared pool is too small and queries are aging out of the shared pool and need to be reparsed.  This is another form of thrashing which also degrades performance tremendously. So, if you run some SQL and it has to be parsed every time you execute it (because no plan exists for this statement) then your percentage would be 0%. The more times that your SQL statement can reuse an existing plan the higher your Execute to Parse ratio is. This is very BAD!! One way to increase your parse ratio is to use bind variables.
Parse CPU to Parse Elapsd %: Generally, this is a measure of how available your CPU cycles were for SQL parsing. If this is low, you may see "latch free" as one of your top wait events.
Redo Nowait Ratio. This ratio indicates the amount of redo entries generated for which there was space available in the redo log. The instance didn't have to wait to use the redo log if this is 100%
The redo-log space-request statistic is incremented when an Oracle process attempts to write a redo-log entry but there is not sufficient space remaining in the online redo log. Thus, a value close to 100 percent for the redo nowait ratio indicates minimal time spent waiting for redo logs to become available, either because the logs are not filling up very often or because the database is able to switch to a new log quickly whenever the current log fills up.
If your alert log shows that you are switching logs frequently (that is, more than once every 15 minutes), you may be able to reduce the amount of switching by increasing the size of the online redo logs. If the log switches are not frequent, check the disks on which the redo logs reside to see why the switches are not happening quickly. If these disks are not overloaded, they may be slow, which means you could put the files on faster disks.
In-Memory Sort Ratio. This ratio gives the percentage of sorts that were performed in memory, rather than requiring a disk-sort segment to complete the sort. Optimally, in an OLTP environment, this ratio should be high. Setting the PGA_AGGREGATE_TARGET (or SORT_AREA_SIZE) initialization parameter effectively will eliminate this problem, as a minimum you pretend to have this one in 95%
Soft Parse Ratio. This ratio gives the percentage of parses that were soft, as opposed to hard. A soft parse occurs when a session attempts to execute a SQL statement and a usable version of the statement is already in the shared pool. In other words, all data (such as the optimizer execution plan) pertaining to the statement in the shared pool is equally applicable to the statement currently being issued. A hard parse, on the other hand, occurs when the current SQL statement is either not in the shared pool or not there in a shareable form. An example of the latter case would be when the SQL statement in the shared pool is textually identical to the current statement but the tables referred to in the two statements resolve to physically different tables.
Hard parsing is an expensive operation and should be kept to a minimum in an OLTP environment. The aim is to parse once, execute many times.
Ideally, the soft parse ratio should be greater than 95 percent. When the soft parse ratio falls much below 80 percent, investigate whether you can share SQL by using bind variables or force cursor sharing by using the init.ora parameter cursor_sharing.
Before you jump to any conclusions about your soft parse ratio, however, be sure to compare it against the actual hard and soft parse rates shown in the Load Profile. If the rates are low (for example, 1 parse per second), parsing may not be a significant issue in your system. Another useful standard of comparison is the proportion of parse time that was not CPU-related, given by the following ratio:
(parse time CPU) / (parse time elapsed)

A low value for this ratio could mean that the non-CPU-related parse time was spent waiting for latches, which might indicate a parsing or latching problem. To investigate further, look at the shared-pool and library-cache latches in the Latch sections of the report for indications of contention on these latches.
Latch Hit Ratio. This is the ratio of the total number of latch misses to the number of latch gets for all latches. A low value for this ratio indicates a latching problem, whereas a high value is generally good. However, as the data is rolled up over all latches, a high latch hit ratio can artificially mask a low get rate on a specific latch. Cross-check this value with the Top 5 Wait Events to see if latch free is in the list, and refer to the Latch sections of the report. Latch Hit % of less than 99 percent is usually a big problem.
Also check the "Shared Pool Statistics", if the "End" value is in the high 95%-100% range ,this is a indication that the shared pool needs to be increased (especially if the "Begin" value is much smaller)



Example: Evaluating the Instance Efficiency Percentages Section

Instance Efficiency Percentages (Target 100%)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            Buffer Nowait %:   99.99       Redo NoWait %:  100.00
            Buffer  Hit   %:   95.57    In-memory Sort %:   97.55
            Library Hit   %:   99.89        Soft Parse %:   99.72
         Execute to Parse %:   88.75         Latch Hit %:   99.11
Parse CPU to Parse Elapsd %:   52.66     % Non-Parse CPU:   99.99

Interpreting the ratios in this section can be slightly more complex than it may seem at first glance. While high values for the ratios are generally good (indicating high efficiency), such values can be misleading your system may be doing something efficiently that it would be better off not doing at all. Similarly, low values aren't always bad. For example, a low in-memory sort ratio (indicating a low percentage of sorts performed in memory) would not necessarily be a cause for concern in a decision- support system (DSS) environment, where user response time is less critical than in an online transaction processing (OLTP) environment.
Basically, you need to keep in mind the characteristics of your application - whether it is query-intensive or update-intensive, whether it involves lots of sorting, and so on - when you're evaluating the Instance Efficiency Percentages.

The following ratios should be above 90% in a database.
Buffer Nowait
Buffer  Hit  
Library Hit
Redo NoWait
In-memory Sort
Soft Parse
Latch Hit
Non-Parse CPU

The execute to parse ratio should be very high in a ideal database.
The execute to parse ratio is basically a measure between the number of times a sql is executed versus the number of times it is parsed.
The ratio will move higher as the number of executes go up, while the number of parses either go down or remain the same.
The ratio will be close to zero if the number of executes and parses are almost equal.
The ratio will be negative executes are lower but the parses are higher.

Another Sample Analysis
Instance Efficiency Percentages (Target 100%)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            Buffer Nowait %:   98.56       Redo NoWait %:  100.00
            Buffer  Hit   %:   99.96    In-memory Sort %:   99.84
            Library Hit   %:   99.99        Soft Parse %:  100.00 (A)
         Execute to Parse %:    0.10 (A)     Latch Hit %:   99.37
Parse CPU to Parse Elapsd %:   58.19 (A) % Non-Parse CPU:   99.84

 Shared Pool Statistics        Begin   End
                               ------  ------
             Memory Usage %:   28.80   29.04 (B)
    % SQL with executions>1:   75.91   76.03
  % Memory for SQL w/exec>1:   83.65   84.09

Observations:
• The 100% soft parse ratio (A) indicates the system is not hard-parsing. However the system is soft parsing a lot, rather than only re-binding and re-executing the same cursors, as the Execute to Parse % is very low (A). Also, the CPU time used for parsing (A) is only 58% of the total elapsed parse time (see Parse CPU to Parse Elapsd). This may also imply some resource contention during parsing (possibly related to the latch free event?).
• There seems to be a lot of unused memory in the shared pool (only 29% is used) (B). If there is insufficient memory allocated to other areas of the database (or OS), this memory could be redeployed

***Please see the following NOTES on shared pool issues
[NOTE:146599.1] Diagnosing and Resolving Error ORA-04031
[NOTE:62143.1] Understanding and Tuning the Shared Pool
[NOTE:105813.1] SCRIPT TO SUGGEST MINIMUM SHARED POOL SIZE

Memory Usage % = It's the shared pool usage. So here we have use 73.86 per cent of our shared pool and out of that almost 94 percent is being re-used. If Memory Usage % is too large like 90 % it could mean that your shared pool is tool small and if the percent is in 50 for example then this could mean that you shared pool is too large
% SQL with executions>1 = Shows % of SQLs executed more than 1 time. The % should be very near to value 100. If we get a low number here, then the DB is not using shared SQL statements. May be because bind variables are not being used.
% memory for SQL w/exec>1: From the memory space allocated to cursors, shows which % has been used by cursors more than 1.

Top 5 Timed Foreground Events
This section provides insight into what events the Oracle database is spending most of it's time on (see wait events). Each wait event is listed, along with the number of waits, the time waited (in seconds), the average wait per event (in microseconds) and the associated wait class. This is one of the most important sections of the report.

Top 5 Timed Foreground Events
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                                           Avg
                                                          wait   % DB
Event                                 Waits     Time(s)   (ms)   time Wait Class
------------------------------ ------------ ----------- ------ ------ ----------
db file sequential read              35,732       6,575    184   77.5 User I/O
log file sync                         3,825       1,495    391   17.6 Commit
db file parallel read                   545         166    304    2.0 User I/O
db file scattered read                  470          92    196    1.1 User I/O
resmgr:cpu quantum                      155          60    385     .7 Scheduler
Host CPU (CPUs:    2 Cores:    2 Sockets:    1)
~~~~~~~~         Load Average
               Begin       End     %User   %System      %WIO     %Idle
           --------- --------- --------- --------- --------- ---------
                7.15     17.70       9.4       4.6      80.5      84.7

Instance CPU
~~~~~~~~~~~~
              % of total CPU for Instance:       7.3
              % of busy  CPU for Instance:      47.5
  %DB time waiting for CPU - Resource Mgr:       0.7

Memory Statistics
~~~~~~~~~~~~~~~~~                       Begin          End
                  Host Mem (MB):      2,002.5      2,002.5
                   SGA use (MB):        756.0        756.0
                   PGA use (MB):         60.6        105.0
    % Host Mem used for SGA+PGA:        40.78        43.00

It's critical to look into this section. If you turn off the statistic parameter, then the Time(s) wont appear. Wait analysis should be done with respect to Time(s) as there could be million of waits but if that happens for a second or so then who cares. Therefore, time is very important component.
When you are trying to eliminate bottlenecks on your system, your report's Top 5 Timed Events section is the first place to look and you should use the HIGHEST WAIT TIMES to guide the investigation.

As you will see, you have several different types of waits, so let's discuss the most common waits on the next section.

Common WAIT EVENTS

If you want a quick instance wide wait event status, showing which events are the biggest contributors to total wait time, you can use the following query :

select event, total_waits,time_waited from V$system_event
  where event NOT IN
  ('pmon timer', 'smon timer', 'rdbms ipc reply', 'parallel deque wait',
  'virtual circuit', '%SQL*Net%', 'client message', 'NULL event')
order by time_waited desc;

EVENT                              TOTAL_WAITS         TIME_WAITED
------------------------          -------------       -------------
db file sequential read              35051309            15965640
latch free                            1373973             1913357
db file scattered read                2958367             1840810
enqueue                                  2837              370871
buffer busy waits                      444743              252664
log file parallel write                146221              123435


1. DB File Scattered Read.
That generally happens during a full scan of a table or Fast Full Index Scans. As full table scans are pulled into memory, they rarely fall into contiguous buffers but instead are scattered throughout the buffer cache. A large number here indicates that your table may have missing indexes, statistics are not updated or your indexes are not used. Although it may be more efficient in your situation to perform a full table scan than an index scan, check to ensure that full table scans are necessary when you see these waits. Try to cache small tables to avoid reading them in over and over again, since a full table scan is put at the cold end of the LRU (Least Recently Used) list. You can use the report to help identify the query in question and fix it.
The init.ora parameter db_file_multiblock_read_count specifies the maximum numbers of blocks read in that way. Typically, this parameter should have values of 4-16 independent of the size of the database but with higher values needed with smaller Oracle block sizes. If you have a high wait time for this event, you either need to reduce the cost of I/O, e.g. by getting faster disks or by distributing your I/O load better, or you need to reduce the amount of full table scans by tuning SQL statements. The appearance of the‘db file scattered read’ and ‘db file sequential read’events may not necessarily indicate a problem, as IO is a normal activity on a healthy instance. However, they can indicate problems if any of the following circumstances are true:
• The data-access method is bad (that is, the SQL statements are poorly tuned), resulting in unnecessary or inefficient IO operations
• The IO system is overloaded and performing poorly
• The IO system is under-configured for the load
• IO operations are taking too long

If this Wait Event is a significant portion of Wait Time then a number of approaches are possible:
o Find which SQL statements perform Full Table or Fast Full Index scans and tune them to make sure these scans are necessary and not the result of a suboptimal plan.
- The view V$SQL_PLAN view can help:
For Full Table scans:
select sql_text from v$sqltext t, v$sql_plan p
  where t.hash_value=p.hash_value
    and p.operation='TABLE ACCESS'
    and p.options='FULL'
  order by p.hash_value, t.piece;

For Fast Full Index scans:
select sql_text from v$sqltext t, v$sql_plan p
  where t.hash_value=p.hash_value
    and p.operation='INDEX'
    and p.options='FULL SCAN'
  order by p.hash_value, t.piece;

o In cases where such multiblock scans occur from optimal execution plans it is possible to tune the size of multiblock I/Os issued by Oracle by setting the instance parameter DB_FILE_MULTIBLOCK_READ_COUNT so that:
DB_BLOCK_SIZE x DB_FILE_MULTIBLOCK_READ_COUNT = max_io_size of system
Query tuning should be used to optimize online SQL to use indexes.

2. DB File Sequential Read.
Is the wait that comes from the physical side of the database. It related to memory starvation and non selective index use. Sequential read is an index read followed by table read because it is doing index lookups which tells exactly which block to go to.
This could indicate poor joining order of tables or un-selective indexes in your SQL or waiting for writes to TEMP space (direct loads, Parallel DML (PDML) such as parallel updates. It could mean that a lot of index reads/scans are going on. Depending on the problem it may help to tune PGA_AGGREGATE_TARGET and/or DB_CACHE_SIZE.
The sequential read event identifies Oracle reading blocks sequentially, i.e. one after each other. It is normal for this number to be large for a high-transaction, well-tuned system, but it can indicate problems in some circumstances. You should correlate this wait statistic with other known issues within the report, such as inefficient SQL. Check to ensure that index scans are necessary, and check join orders for multiple table joins. The DB_CACHE_SIZE will also be a determining factor in how often these waits show up. Problematic hash-area joins should show up in the PGA memory, but they're also memory hogs that could cause high wait numbers for sequential reads. They can also show up as direct path read/write waits. These circumstances are usually interrelated. When they occur in conjunction with the appearance of the 'db file scattered read' and 'db file sequential read' in the Top 5 Wait Events section, first you should examine the SQL Ordered by Physical Reads section of the report, to see if it might be helpful to tune the statements with the highest resource usage.
It could be because the indexes are fragmented. If that is the case, rebuilding the index will compact it and will produce to visit less blocks.
Then, to determine whether there is a potential I/O bottleneck, examine the OS I/O statistics for corresponding symptoms. Also look at the average time per read in the Tablespace and File I/O sections of the report. If many I/O-related events appear high in the Wait Events list, re-examine the host hardware for disk bottlenecks and check the host-hardware statistics for indications that a disk reconfiguration may be of benefit.
Block reads are fairly inevitable so the aim should be to minimize unnecessary I/O. I/O for sequential reads can be reduced by tuning SQL calls that result in full table scans and using the partitioning option for large tables.

3. Free Buffer Waits.
When a session needs a free buffer and cannot find one, it will post the database writer process asking it to flush dirty blocks (No place to put a new block). Waits in this category may indicate that you need to increase the DB_BUFFER_CACHE, if all your SQL is tuned. Free buffer waits could also indicate that unselective SQL is causing data to flood the buffer cache with index blocks, leaving none for this particular statement that is waiting for the system to process. This normally indicates that there is a substantial amount of DML (insert/update/delete) being done and that the Database Writer (DBWR) is not writing quickly enough; the buffer cache could be full of multiple versions of the same buffer, causing great inefficiency. To address this, you may want to consider accelerating incremental checkpointing, using more DBWR processes, or increasing the number of physical disks. To investigate if this is an I/O problem, look at the report I/O Statistics. Increase the DB_CACHE_SIZE; shorten the checkpoint; tune the code to get less dirty blocks, faster I/O, use multiple DBWR’s.

4. Buffer Busy Waits. A buffer busy wait happens when multiple processes concurrently want to modify the same block in the buffer cache. This typically happens during massive parallel inserts if your tables do not have free lists and it can happen if you have too few rollback segments. Buffer busy waits should not be greater than 1 percent. Check the Buffer Wait Statistics section (or V$WAITSTAT) to find out if the wait is on a segment header. If this is the case, increase the freelist groups or increase the pctused to pctfree gap. If the wait is on an undo header, you can address this by adding rollback segments; if it's on an undo block, you need to reduce the data density on the table driving this consistent read or increase the DB_CACHE_SIZE. If the wait is on a data block, you can move data to another block to avoid this hot block, increase the freelists on the table, or use Locally Managed Tablespaces (LMTs). If it's on an index block, you should rebuild the index, partition the index, or use a reverse key index. To prevent buffer busy waits related to data blocks, you can also use a smaller block size: fewer records fall within a single block in this case, so it's not as "hot." When a DML (insert/update/ delete) occurs, Oracle writes information into the block, including all users who are "interested" in the state of the block (Interested Transaction List, ITL). To decrease waits in this area, you can increase the initrans, which will create the space in the block to allow multiple ITL slots. You can also increase the pctfree on the table where this block exists (this writes the ITL information up to the number specified by maxtrans, when there are not enough slots built with the initrans that is specified). Buffer busy waits can be reduced by using reverse-key indexes for busy indexes and by partitioning busy tables.
Buffer Busy Wait on Segment Header – Add freelists (if inserts) or freelist groups (esp. RAC). Use ASSM.
Buffer Busy Wait on Data Block – Separate ‘hot’ data; potentially use reverse key indexes; fix queries to reduce the blocks popularity, use smaller blocks, I/O, Increase initrans and/or maxtrans (this one’s debatable). Reduce records per block
Buffer Busy Wait on Undo Header – Add rollback segments or increase size of segment area (auto undo) 
Buffer Busy Wait on Undo block – Commit more (not too much) Larger rollback segments/area. Try to fix the SQL.


5. Latch Free. Latches are low-level queuing mechanisms (they're accurately referred to as mutual exclusion mechanisms) used to protect shared memory structures in the system global area (SGA). Latches are like locks on memory that are very quickly obtained and released. Latches are used to prevent concurrent access to a shared memory structure. If the latch is not available, a latch free miss is recorded. Most latch problems are related to the failure to use bind variables (library cache latch), redo generation issues (redo allocation latch), buffer cache contention issues (cache buffers LRU chain), and hot blocks in the buffer cache (cache buffers chain). There are also latch waits related to bugs; check MetaLink for bug reports if you suspect this is the case. When latch miss ratios are greater than 0.5 percent, you should investigate the issue. If latch free waits are in the Top 5 Wait Events or high in the complete Wait Events list, look at the latch-specific sections of the report to see which latches are contended for.

6. Enqueue. An enqueue is a lock that protects a shared resource. Locks protect shared resources, such as data in a record, to prevent two people from updating the same data at the same time application, e.g. when a select for update is executed.. An enqueue includes a queuing mechanism, which is FIFO (first in, first out). Note that Oracle's latching mechanism is not FIFO. Enqueue waits usually point to the ST enqueue, the HW enqueue, the TX4 enqueue, and the TM enqueue. The ST enqueue is used for space management and allocation for dictionary-managed tablespaces. Use LMTs, or try to preallocate extents or at least make the next extent larger for problematic dictionary-managed tablespaces. HW enqueues are used with the high-water mark of a segment; manually allocating the extents can circumvent this wait. TX4s are the most common enqueue waits. TX4 enqueue waits are usually the result of one of three issues. The first issue is duplicates in a unique index; you need to commit/rollback to free the enqueue. The second is multiple updates to the same bitmap index fragment. Since a single bitmap fragment may contain multiple rowids, you need to issue a commit or rollback to free the enqueue when multiple users are trying to update the same fragment. The third and most likely issue is when multiple users are updating the same block. If there are no free ITL slots, a block-level lock could occur. You can easily avoid this scenario by increasing the initrans and/or maxtrans to allow multiple ITL slots and/or by increasing the pctfree on the table. Finally, TM enqueues occur during DML to prevent DDL to the affected object. If you have foreign keys, be sure to index them to avoid this general locking issue.
Enqueue - ST Use LMT’s or pre-allocate large extents
Enqueue - HW Pre-allocate extents above HW (high water mark.)
Enqueue – TX Increase initrans and/or maxtrans (TX4) on (transaction) the table or index.  Fix locking issues if TX6.  Bitmap (TX4) & Duplicates in Index (TX4).
Enqueue - TM Index foreign keys; Check application (trans. mgmt.) locking of tables.  DML Locks.

7. Log Buffer Space
Look at increasing log buffer size. This wait occurs because you are writing the log buffer faster than LGWR can write it to the redo logs, or because log switches are too slow. To address this problem, increase the size of the redo log files, or increase the size of the log buffer, or get faster disks to write to. You might even consider using solid-state disks, for their high speed.
The session is waiting for space in the log buffer. (Space becomes available only after LGWR has written the current contents of the log buffer to disk.) This typically happens when applications generate redo faster than LGWR can write it to disk.

8. Log File Switch
log file switch (checkpoint incomplete): May indicate excessive db files or slow IO subsystem
log file switch (archiving needed):  Indicates archive files are written too slowly
log file switch completion: May need more log files per
May indicate excessive db files or slow IO subsystem. All commit requests are waiting for "logfile switch (archiving needed)" or "logfile switch (chkpt. Incomplete)." Ensure that the archive disk is not full or slow. DBWR may be too slow because of I/O. You may need to add more or larger redo logs, and you may potentially need to add database writers if the DBWR is the problem.

9. Log File Sync
Could indicate excessive commits. A Log File Sync happens each time a commit (or rollback) takes place. If there are a lot of waits in this area then you may want to examine your application to see if you are committing too frequently (or at least more than you need to). When a user commits or rolls back data, the LGWR flushes the session's redo from the log buffer to the redo logs. The log file sync process must wait for this to successfully complete. To reduce wait events here, try to commit more records (try to commit a batch of 50 instead of one at a time, use BULKS, , for example). Put redo logs on a faster disk, or alternate redo logs on different physical disks (with no other DB Files, ASM, etc) to reduce the archiving effect on LGWR. Don't use RAID 5, since it is very slow for applications that write a lot; potentially consider using file system direct I/O or raw devices, which are very fast at writing information. The associated event, ‘log buffer parallel write’ is used by the redo log writer process, and it will indicate if your actual problem is with the log file I/O. Large wait times for this event can also be caused by having too few CPU resources available for the redolog writer process.

10. Idle Event. There are several idle wait events listed after the output; you can ignore them. Idle events are generally listed at the bottom of each section and include such things as SQL*Net message to/from client and other background-related timings. Idle events are listed in the stats$idle_event table.

11. global cache cr request: (OPS) This wait event shows the amount of time that an instance has waited for a requested data block for a consistent read and the transferred block has not yet arrived at the requesting instance. See Note 157766.1 'Sessions Wait Forever for 'global cache cr request' Wait Event in OPS or RAC'. In some cases the 'global cache cr request' wait event may be perfectly normal if large buffer caches are used and the same data is being accessed concurrently on multiple instances.  In a perfectly tuned, non-OPS/RAC database, I/O wait events would be the top wait events but since we are avoiding I/O's with RAC and OPS the 'global cache cr request' wait event often takes the place of I/O wait events.

12. library cache pin: Library cache latch contention may be caused by not using bind variables. It is due to excessive parsing of SQL statement.
The session wants to pin an object in memory in the library cache for examination, ensuring no other processes can update the object at the same time. This happens when you are compiling or parsing a PL/SQL object or a view.

13. CPU time
This is not really a wait event (hence, the new name), but rather the sum of the CPU used by this session, or the amount of CPU time used during the snapshot window. In a heavily loaded system, if the CPU time event is the biggest event, that could point to some CPU-intensive processing (for example, forcing the use of an index when a full scan should have been used), which could be the cause of the bottleneck. When CPU Other is a significant component of total Response Time the next step is to find the SQL statements that access the most blocks. Block accesses are also known as Buffer Gets and Logical I/Os. The report lists such SQL statements in section SQL ordered by Gets.

14. DB File Parallel Read  If you are doing a lot of partition activity then expect to see that wait even. it could be a table or index partition. This Wait Event is used when Oracle performs in parallel reads from multiple datafiles to non-contiguous buffers in memory (PGA or Buffer Cache). This is done during recovery operations or when buffer prefetching is being used as an optimization i.e. instead of performing multiple single-block reads. If this wait is an important component of Wait Time, follow the same guidelines as 'db file sequential read'.
This may occur during recovery or during regular activity when a session batches many single block I/O requests together and issues them in parallel.

15. PX qref latch  Can often mean that the Producers are producing data quicker than the Consumers can consume it. Maybe we could increase parallel_execution_message_size to try to eliminate some of these waits or we might decrease the degree of parallelism. If the system workload is high consider to decrease the degree of parallelism. If you have DEFAULT parallelism on your object  you can decrease the value of PARALLEL_THREADS_PER_CPU.  Have in mind  DEFAULT degree = PARALLEL_THREADS_PER_CPU * #CPU's 

16. Log File Parallel Write. It occurs when waiting for writes of REDO records to the REDO log files to complete. The wait occurs in log writer (LGWR) as part of normal activity of copying records from the REDO log buffer to the current online log. The actual wait time is the time taken for all the outstanding I/O requests to complete. Even though the writes may be issued in parallel, LGWR needs to wait for the last I/O to be on disk before the parallel write is considered complete. Hence the wait time depends on the time it takes the OS to complete all requests.
Log file parallel write waits can be reduced by moving log files to the faster disks and/or separate disks where there will be less contention.

17. SQL*Net more data to client
This means the instance is sending a lot of data to the client. You can decrease this time by having the client bring back less data. Maybe the application doesn't need to bring back as much data as it is.

18. SQL*Net message to client
The “SQL*Net message to client” Oracle metric indicates the server (foreground process) is sending a message to the client, and it can be used to identify throughput issues over a network, especially distributed databases with slow database links. The SQL*Net more data to client event happens when Oracle writes multiple data buffers (sized per SDU) in a single logical network call.

19. enq: TX - row lock contention:
Oracle keeps data consistency with the help of locking mechanism. When a particular row is being modified by the process, either through Update/ Delete or Insert operation, oracle tries to acquire lock on that row. Only when the process has acquired lock the process can modify the row otherwise the process waits for the lock. This wait situation triggers this event. The lock is released whenever a COMMIT is issued by the process which has acquired lock for the row. Once the lock is released, processes waiting on this event can acquire lock on the row and perform DML operation

20. direct Path writes: You wont see them unless you are doing some appends or data loads. The session has issued asynchronous I/O requests that bypass the buffer cache and is waiting for them to complete. These wait events often involve temporary segments, sorting activity, parallel query or hash joins.


21. direct Path reads / direct path writes: Could happen if you are doing a lot of parallel query activity. The session has issued asynchronous I/O requests that bypass the buffer cache and is waiting for them to complete. These wait events often involve temporary segments, sorting activity, parallel query or hash joins. Usually sorting to Temp. Can also be parallel query. Could also be insert append, etc Adjust PGA_AGGREGATE_TARGET to fix it.

22. write complete waits: The session is waiting for a requested buffer to be written to disk; the buffer cannot be used while it is being written.


23. direct path read temp or direct path write temp: This wait event shows Temp file activity (sort,hashes,temp tables, bitmap) check pga parameter or sort area or hash area parameters. You might want to increase them


24. Undo segment extension: The session is waiting for an undo segment to be extended or shrunk. If excessive, tune undo


25. wait for a undo record: Usually only during recovery of large transactions, look at turning off parallel undo recovery.


26. Control File Parallel Write: The session has issued multiple I/O requests in parallel to write blocks to all control files, and is waiting for all of the writes to complete.


27. Control File Sequential Read: The session is waiting for blocks to be read from a control file.


28. DB File Parallel Write: The process, typically DBWR, has issued multiple I/O requests in parallel to write dirty blocks from the buffer cache to disk and is waiting for all requests to complete.


29. Library Cache load lock: The session is waiting for the opportunity to load an object or a piece of an object into the library cache. (Only one process can load an object or a piece of an object at a time.)


30. log file sequential read: The session is waiting for blocks to be read from the online redo log into memory. This primarily occurs at instance startup and when the ARCH process archives filled online redo logs.
 

Time Model Statistics
Oracle Database time model related statistics are presented next. The time model allows you to see a summary of where the database is spending it's time. The report will present the various time related statistic (such as DB CPU) and how much total time was spent in the mode of operation represented by that statistic. Here is an example of the time model statistic report:

    Total time in database user-calls (DB Time): 20586.1s
    Statistics including the word "background" measure background process time, and so do not contribute to the DB time statistic
    Ordered by % or DB time desc, Statistic name
    
Time Model Statistics                        DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total time in database user-calls (DB Time): 8484.3s
-> Statistics including the word "background" measure background process
   time, and so do not contribute to the DB time statistic
-> Ordered by % or DB time desc, Statistic name

Statistic Name                                       Time (s) % of DB Time
------------------------------------------ ------------------ ------------
sql execute elapsed time                              6,967.9         82.1 @jls
DB CPU                                                   50.2           .6
PL/SQL execution elapsed time                            48.7           .6
parse time elapsed                                       41.1           .5
hard parse elapsed time                                  40.2           .5
connection management call elapsed time                   5.7           .1
PL/SQL compilation elapsed time                           3.3           .0
repeated bind elapsed time                                0.1           .0
hard parse (sharing criteria) elapsed time                0.0           .0
sequence load elapsed time                                0.0           .0
hard parse (bind mismatch) elapsed time                   0.0           .0
DB time                                               8,484.3
background elapsed time                                 424.3
background cpu time                                       3.1
          -------------------------------------------------------------
If parsing time is very high, or if hard parsing is significant, you must investigate it further. You should not expect the % of DB Time to add up to 100% because there is overlap among statistics.
Generally you want SQL processing time high, parsing and other stuff low. Time related statistics presents the various operations which are consuming most of the database time.
If SQL time>>DB CPU time then probably have IO issues. 
If Hard parses or parsing time is very high then further investigation should be done to resolve the problem. .

Example

Statistic Name                                  Time (s)            % of DB Time

sql execute elapsed time                        12,416.14           86.45
DB CPU                                          9,223.70            64.22
parse time elapsed                              935.61              6.51
hard parse elapsed time                         884.73              6.16
failed parse elapsed time                       821.39              5.72
PL/SQL execution elapsed time                   153.51              1.07
hard parse (sharing criteria) elapsed time      25.96               0.18
connection management call elapsed time         14.00               0.10
hard parse (bind mismatch) elapsed time         4.74                0.03
PL/SQL compilation elapsed time                 1.20                0.01
repeated bind elapsed time                      0.22                0.00
sequence load elapsed time                      0.11                0.00
DB time                                         14,362.96
background elapsed time                         731.00
background cpu time                             72.00

In the above example, 9,223.70 seconds CPU time was used for all user sessions. This was just under 65% of database resources. 
In total there was 14363 seconds database time used. 
The total wait event time can be calculated as 14363 – 9223.70 = 5139.3 seconds. The lion share of database time (86.45%) was spent on executing sql which is a good sign. The total parse time was 935.61 seconds of which 884.73 seconds was hard parsing. The rest of statistics is tiny in this case

Operating System Statistics

This part of the report provides some basic insight into OS performance, and OS configuration too. This report may vary depending on the OS platform that your database is running on. Here is an example from a Linux system:

    *TIME statistic values are diffed. All others display actual values. End Value is displayed if different
    ordered by statistic type (CPU Use, Virtual Memory, Hardware Config), Name

Operating System Statistics                   DB/Inst: ORCL/orcl  Snaps: 37-38
-> *TIME statistic values are diffed.
   All others display actual values.  End Value is displayed if different
-> ordered by statistic type (CPU Use, Virtual Memory, Hardware Config), Name

Statistic                                  Value        End Value
------------------------- ---------------------- ----------------
BUSY_TIME                                 11,245
IDLE_TIME                                 62,275
IOWAIT_TIME                               59,179
NICE_TIME                                     41
SYS_TIME                                   3,362
USER_TIME                                  6,894
LOAD                                           7               18
RSRC_MGR_CPU_WAIT_TIME                     5,819
PHYSICAL_MEMORY_BYTES              2,099,740,672
NUM_CPUS                                       2
NUM_CPU_CORES                                  2
NUM_CPU_SOCKETS                                1
GLOBAL_RECEIVE_SIZE_MAX                  131,071
GLOBAL_SEND_SIZE_MAX                     131,071
TCP_RECEIVE_SIZE_DEFAULT                  87,380
TCP_RECEIVE_SIZE_MAX                   4,194,304
TCP_RECEIVE_SIZE_MIN                       4,096
TCP_SEND_SIZE_DEFAULT                     16,384
TCP_SEND_SIZE_MAX                      4,194,304
TCP_SEND_SIZE_MIN                          4,096
          -------------------------------------------------------------

Operating System Statistics - Detail          DB/Inst: ORCL/orcl  Snaps: 37-38

Snap Time           Load    %busy    %user     %sys    %idle  %iowait
--------------- -------- -------- -------- -------- -------- --------
12-Feb 12:16:04      7.1      N/A      N/A      N/A      N/A      N/A
12-Feb 12:22:06     17.7     15.3      9.4      4.6     84.7     80.5
          -------------------------------------------------------------

Foreground Wait Class and Foreground Wait Events  
Closely associated with the time model section of the report are the Foreground wait class and Foreground wait event statistics sections. 
Within Oracle, the duration of a large number of operations  (e.g. Writing to disk or to the control file) is metered. These are known as wait events, because each of these operations requires the system to wait for the event to complete. 
Thus, the execution of some database operation (e.g. a SQL query) will have a number of wait events associated with it. We can try to determine which wait events are causing us problems by looking at the wait classes and the wait event reports generated from AWR.
Wait classes define "buckets" that allow for summation of various wait times. Each wait event is assigned to one of these buckets (for example System I/O or User I/O). These buckets allow one to quickly determine which subsystem is likely suspect in performance problems  (e.g. the network, or the cluster).

Foreground Wait Class                         DB/Inst: ORCL/orcl  Snaps: 37-38
-> s  - second, ms - millisecond -    1000th of a second
-> ordered by wait time desc, waits desc
-> %Timeouts: value of 0 indicates value was < .5%.  Value of null is truly 0
-> Captured Time accounts for         99.6%  of Total DB time       8,484.33 (s)
-> Total FG Wait Time:             8,402.19 (s)  DB CPU time:          50.24 (s)

                                                                  Avg
                                      %Time       Total Wait     wait
Wait Class                      Waits -outs         Time (s)     (ms)  %DB time
-------------------- ---------------- ----- ---------------- -------- ---------
User I/O                       37,056     0            6,840      185      80.6 @jls
Commit                          3,825     0            1,495      391      17.6
Scheduler                         155     0               60      385       0.7
DB CPU                                                    50                0.6
Other                             159    83                3       20       0.0
Concurrency                       128     0                3       25       0.0
System I/O                         97     0                0        2       0.0
Network                         6,298     0                0        0       0.0
          -------------------------------------------------------------

Here is an example of the wait class report section:

          -------------------------------------------------------------

Foreground Wait Class                               DB/Inst: A109/a1092  Snaps: 2009-2010
-> s  - second
-> cs - centisecond -     100th of a second
-> ms - millisecond -    1000th of a second
-> us - microsecond - 1000000th of a second
-> ordered by wait time desc, waits desc
                                                                  Avg
                                       %Time       Total Wait    wait     Waits
Wait Class                      Waits  -outs         Time (s)    (ms)      /txn
-------------------- ---------------- ------ ---------------- ------- ---------
System I/O                      8,142     .0               25       3      10.9
Other                         439,596   99.6                3       0     589.3
User I/O                          112     .0                0       3       0.2
Cluster                           443     .0                0       0       0.6
Concurrency                       216     .0                0       0       0.3
Commit                             16     .0                0       2       0.0
Network                         3,526     .0                0       0       4.7
Application                        13     .0                0       0       0.0
          -------------------------------------------------------------


In this report the system I/O wait class has the largest number of waits (total of 25 seconds) and an average wait of 3 milliseconds.

Foreground Wait Events
Wait events are normal occurrences, but if a particular sub-system is having a problem performing (e.g. the disk sub-system) this fact will appear in the form of one or more wait events with an excessive duration. 
The wait event report then provides some insight into the detailed wait events. Here is an example of the wait event report (we have eliminated some of the bulk of this report, because it can get quite long). Note that this section is sorted by wait time (listed in microseconds).
          
Foreground Wait Events                       DB/Inst: ORCL/orcl  Snaps: 37-38
-> s  - second, ms - millisecond -    1000th of a second
-> Only events with Total Wait Time (s) >= .001 are shown
-> ordered by wait time desc, waits desc (idle events last)
-> %Timeouts: value of 0 indicates value was < .5%.  Value of null is truly 0

                                                             Avg
                                        %Time Total Wait    wait    Waits   % DB
Event                             Waits -outs   Time (s)    (ms)     /txn   time
-------------------------- ------------ ----- ---------- ------- -------- ------
db file sequential read          35,732     0      6,575     184      4.0   77.5 @jls
log file sync                     3,825     0      1,495     391      0.4   17.6
db file parallel read               545     0        166     304      0.1    2.0
db file scattered read              470     0         92     196      0.1    1.1
resmgr:cpu quantum                  155     0         60     385      0.0     .7
read by other session                64     0          8     122      0.0     .1
latch: enqueue hash chains           18     0          3     175      0.0     .0
latch: shared pool                    8     0          2     253      0.0     .0
latch: row cache objects              5     0          0      95      0.0     .0
library cache: mutex X              100     0          0       4      0.0     .0
control file sequential re           97     0          0       2      0.0     .0
enq: TX - index contention            2     0          0      78      0.0     .0
row cache lock                        1     0          0     155      0.0     .0
latch free                            7     0          0      12      0.0     .0
SQL*Net message to client         6,298     0          0       0      0.7     .0
buffer busy waits                    10     0          0       3      0.0     .0
Disk file operations I/O            240     0          0       0      0.0     .0
asynch descriptor resize            132   100          0       0      0.0     .0
direct path sync                      1     0          0       1      0.0     .0
PL/SQL lock timer                40,655   100      6,140     151      4.5
SQL*Net message from clien        6,298     0      1,766     280      0.7
jobq slave wait                     181    99         90     500      0.0
          -------------------------------------------------------------

Example

Foreground Wait Events 
                                                                   Avg
                                             %Time  Total Wait    wait     Waits
Event                                 Waits  -outs    Time (s)    (ms)      /txn
---------------------------- -------------- ------ ----------- ------- ---------
control file parallel write           1,220     .0          18      15       1.6
control file sequential read          6,508     .0           6       1       8.7
CGS wait for IPC msg                422,253  100.0           1       0     566.0
change tracking file synchro             60     .0           1      13       0.1
db file parallel write                  291     .0           0       1       0.4
db file sequential read                  90     .0           0       4       0.1
reliable message                        136     .0           0       1       0.2
log file parallel write                 106     .0           0       2       0.1
lms flush message acks                    1     .0           0      60       0.0
gc current block 2-way                  200     .0           0       0       0.3
change tracking file synchro             59     .0           0       1       0.1


In this example our control file parallel write waits (which occurs during writes to the control file) are taking up 18 seconds total, with an average wait of 15 milliseconds per wait. 
Additionally we can see that we have 1.6 waits per transaction (or 15ms * 1.6 per transaction = 24ms). 

Background Wait Events

Background wait events are those not associated with a client process. They indicate waits encountered by system and non-system processes. Examples of background system processes are LGWR and DBWR.  An example of a non-system background process would be a parallel query slave.  Note that it is possible for a wait event to appear in both the foreground and background wait events statistics, for examples the enqueue and latch free events.  The idle wait events appear at the bottom of both sections and can generally safely be ignored. Typically these type of events keep record of the time while the client is connected to the database but not requests are being made to the server. Usually not a big contributor.

Background Wait Events                       DB/Inst: ORCL/orcl  Snaps: 37-38
-> ordered by wait time desc, waits desc (idle events last)
-> Only events with Total Wait Time (s) >= .001 are shown
-> %Timeouts: value of 0 indicates value was < .5%.  Value of null is truly 0

                                                             Avg
                                        %Time Total Wait    wait    Waits   % bg
Event                             Waits -outs   Time (s)    (ms)     /txn   time
-------------------------- ------------ ----- ---------- ------- -------- ------
log file parallel write           6,962     0        258      37      0.8   60.8
db file async I/O submit          1,773     0         49      28      0.2   11.6
os thread startup                     9     0         26    2865      0.0    6.1
db file sequential read              51     0         20     396      0.0    4.8
control file parallel writ          170     0         12      70      0.0    2.8
ADR block file read                  12     0          3     253      0.0     .7
control file sequential re          420     0          1       2      0.0     .2
ADR block file write                  5     0          0      60      0.0     .1
LGWR wait for redo copy              24     0          0       9      0.0     .1
db file scattered read                1     0          0      18      0.0     .0
reliable message                     74     0          0       0      0.0     .0
log file sync                         1     0          0      10      0.0     .0
latch free                            4     0          0       3      0.0     .0
rdbms ipc reply                      74     0          0       0      0.0     .0
SQL*Net message to client           240     0          0       0      0.0     .0
latch: shared pool                    1     0          0       2      0.0     .0
asynch descriptor resize             91   100          0       0      0.0     .0
enq: JS - queue lock                  1     0          0       1      0.0     .0
rdbms ipc message                 4,392    32      5,463    1244      0.5
DIAG idle wait                      729   100        730    1001      0.1
Space Manager: slave idle            73   100        365    5001      0.0
pmon timer                          138    88        364    2640      0.0
Streams AQ: qmn coordinato           26    50        364   14003      0.0
Streams AQ: qmn slave idle           14     0        363   25934      0.0
shared server idle wait              12   100        360   30011      0.0
dispatcher timer                      6   100        360   60012      0.0
smon timer                           11     0        211   19145      0.0
SQL*Net message from clien          320     0          2       7      0.0
class slave wait                      4     0          0       9      0.0
          -------------------------------------------------------------

Wait Event Histogram                         DB/Inst: ORCL/orcl  Snaps: 37-38
-> Units for Total Waits column: K is 1000, M is 1000000, G is 1000000000
-> % of Waits: value of .0 indicates value was <.05%; value of null is truly 0
-> % of Waits: column heading of <=1s is truly <1024ms, >1s is truly >=1024ms
-> Ordered by Event (idle events last)

                                                    % of Waits
                                 -----------------------------------------------
                           Total
Event                      Waits  <1ms  <2ms  <4ms  <8ms <16ms <32ms  <=1s   >1s
-------------------------- ----- ----- ----- ----- ----- ----- ----- ----- -----
ADR block file read           12                     8.3   8.3   8.3  75.0
ADR block file write           5  60.0                                40.0
ADR file lock                  6 100.0
Disk file operations I/O     252  99.2    .4          .4
LGWR wait for redo copy       24  83.3                     4.2        12.5
SQL*Net message to client   6538 100.0                      .0
asynch descriptor resize     225 100.0
buffer busy waits             11  63.6         9.1   9.1  18.2
control file parallel writ   175  64.6   9.1   1.1   1.1   2.3   1.1  19.4   1.1
control file sequential re   524  98.3                            .6   1.1
db file async I/O submit    1936  88.0   2.7    .9    .4   1.0   1.3   4.9    .8
db file parallel read        545   1.7                     1.5   5.0  89.4   2.6
db file scattered read       471   5.9    .6    .6    .2    .6   8.1  83.2    .6
db file sequential read    35.9K   7.0    .0    .0    .3   2.9  12.2  75.9   1.6
direct path sync               2  50.0  50.0
direct path write              4 100.0
direct path write temp         1 100.0
enq: JS - queue lock           1       100.0
enq: TX - index contention     2              50.0                    50.0
latch free                    11  45.5         9.1        18.2  27.3
latch: In memory undo latc     2 100.0
latch: cache buffers chain     1 100.0
latch: cache buffers lru c     1 100.0
latch: call allocation         1 100.0
latch: enqueue hash chains    18                          11.1        88.9
latch: object queue header     1 100.0
latch: redo allocation         1 100.0
latch: row cache objects       5                                     100.0
latch: shared pool             9  22.2  11.1  33.3  11.1              22.2
library cache: mutex X       100  82.0   6.0   5.0   3.0         1.0   3.0
log file parallel write     6966  70.3   1.2    .4   1.6   4.6   9.5  11.8    .6
log file sync               3825   5.1    .9    .4   1.6   3.6   7.9  70.4  10.2
os thread startup              9                                33.3  44.4  22.2
rdbms ipc reply               75  98.7   1.3
read by other session         64   1.6   3.1   4.7   1.6   9.4  26.6  53.1
reliable message              74  97.3   2.7
resmgr:cpu quantum           155          .6    .6   3.2   4.5   9.7  70.3  11.0
row cache lock                 1                                     100.0
DIAG idle wait               740                                     100.0
PL/SQL lock timer          40.6K    .0                               100.0
SQL*Net message from clien  6616   5.0   1.0    .9    .8    .8    .3  90.8    .3
Space Manager: slave idle     74                                           100.0
Streams AQ: qmn coordinato    28  50.0                                      50.0
Streams AQ: qmn slave idle    15   6.7                                      93.3
class slave wait               4  75.0                                25.0
dispatcher timer               6                                           100.0
jobq slave wait              181                                     100.0
pmon timer                   140  11.4                                  .7  87.9
rdbms ipc message           4410  22.0   1.7   3.7   5.4   9.0  10.6  23.8  23.9
shared server idle wait       12                                           100.0
smon timer                    11                                       9.1  90.9
          -------------------------------------------------------------

Wait Event Histogram Detail (64 msec to 2 sec)DB/Inst: ORCL/orcl  Snaps: 37-3
-> Units for Total Waits column: K is 1000, M is 1000000, G is 1000000000
-> Units for % of Total Waits:
   ms is milliseconds
   s is 1024 milliseconds (approximately 1 second)
-> % of Total Waits: total waits for all wait classes, including Idle
-> % of Total Waits: value of .0 indicates value was <.05%;
   value of null is truly 0
-> Ordered by Event (only non-idle events are displayed)

                                                 % of Total Waits
                                 -----------------------------------------------
                           Waits
                           64ms
Event                      to 2s <32ms <64ms <1/8s <1/4s <1/2s   <1s   <2s  >=2s
-------------------------- ----- ----- ----- ----- ----- ----- ----- ----- -----
ADR block file read            9  25.0  33.3         8.3   8.3  25.0
ADR block file write           2  60.0        20.0  20.0
LGWR wait for redo copy        3  87.5   4.2   8.3
control file parallel writ    36  79.4   3.4   3.4   5.7   2.9   4.0   1.1
control file sequential re     6  98.9          .4    .4    .4
db file async I/O submit     109  94.3   1.0    .7   1.1   1.2    .9    .8    .1
db file parallel read        501   8.1  10.3  15.2  19.1  31.9  12.8   2.6
db file scattered read       395  16.1  13.4  22.3  21.2  19.3   7.0    .6
db file sequential read    27.9K  22.5  15.1  18.9  21.8  14.5   5.7   1.6
enq: TX - index contention     1  50.0              50.0
latch: enqueue hash chains    16  11.1   5.6  16.7  44.4  22.2
latch: row cache objects       5             100.0
latch: shared pool             2  77.8                          22.2
library cache: mutex X         3  97.0   2.0         1.0
log file parallel write      864  87.6   3.0   2.3   2.4   3.1   1.1    .6
log file sync               3073  19.5   5.7   8.9  17.1  22.4  16.3  10.0    .2
os thread startup              4  33.3  22.2        11.1        11.1        22.2
read by other session         34  46.9  10.9  14.1  14.1   9.4   4.7
resmgr:cpu quantum           119  18.7  14.8  19.4  11.6  14.2  10.3   6.5   4.5
row cache lock                 1                   100.0
          -------------------------------------------------------------

Wait Event Histogram Detail (4 sec to 2 min) DB/Inst: ORCL/orcl  Snaps: 37-38
-> Units for Total Waits column: K is 1000, M is 1000000, G is 1000000000
-> Units for % of Total Waits:
   s is 1024 milliseconds (approximately 1 second)
   m is 64*1024 milliseconds (approximately 67 seconds or 1.1 minutes)
-> % of Total Waits: total waits for all wait classes, including Idle
-> % of Total Waits: value of .0 indicates value was <.05%;
   value of null is truly 0
-> Ordered by Event (only non-idle events are displayed)

                                                 % of Total Waits
                                 -----------------------------------------------
                           Waits
                            4s
Event                      to 2m   <2s   <4s   <8s  <16s  <32s  < 1m  < 2m  >=2m
-------------------------- ----- ----- ----- ----- ----- ----- ----- ----- -----
db file async I/O submit       1  99.9    .1
log file sync                  8  99.8    .2
os thread startup              2  77.8              22.2
resmgr:cpu quantum             7  95.5   4.5
          -------------------------------------------------------------

Wait Event Histogram Detail (4 min to 1 hr)  DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Service Statistics
A service is a grouping of processes. Users may be grouped in SYS$USER. Application logins (single user) may be grouped with that user name

Service Statistics                           DB/Inst: ORCL/orcl  Snaps: 37-38
-> ordered by DB Time

                                                           Physical      Logical
Service Name                  DB Time (s)   DB CPU (s)    Reads (K)    Reads (K)
---------------------------- ------------ ------------ ------------ ------------
orcl                                8,337           38           45          573
SYS$USERS                             137           13            2          150
SYS$BACKGROUND                          0            0            0            6
orclXDB                                 0            0            0            0
          -------------------------------------------------------------

Service Wait Class Stats                      DB/Inst: ORCL/orcl  Snaps: 37-38
-> Wait Class info for services in the Service Statistics section.
-> Total Waits and Time Waited displayed for the following wait
   classes:  User I/O, Concurrency, Administrative, Network
-> Time Waited (Wt Time) in seconds

Service Name
----------------------------------------------------------------
 User I/O  User I/O  Concurcy  Concurcy     Admin     Admin   Network   Network
Total Wts   Wt Time Total Wts   Wt Time Total Wts   Wt Time Total Wts   Wt Time
--------- --------- --------- --------- --------- --------- --------- ---------
orcl
    36048      6766       123         2         0         0      6296         0
SYS$USERS
     1002        74         5         1         0         0         2         0
SYS$BACKGROUND
       69        20        11        26         0         0         0         0
          -------------------------------------------------------------

SQL Information Section

Next in the report we find several different reports that present SQL statements that might be improved by tuning. Any SQL statement appears in the top 5 statements in two or more areas below, then it is a prime candidate for tuning. The sections are:

    SQL Ordered by Elapsed Time - IO waits
    SQL Ordered by CPU Time - Sorting, hashing
    SQL Ordered by Buffer Gets - High logical IO
    SQL Ordered by Disk Reads - High physical IO
    SQL Ordered by Executions - May indicate loop issues
    SQL Ordered by Parse Calls - Memory issues
    SQL Ordered by Sharable Memory - Informational
    SQL Ordered by Version Count - May indicate unsafe bind variables
    SQL Ordered by Cluster Wait Time - Indicates physical issues (RPB, block size)

Let try to see what these mean.

SQL Ordered by Elapsed Time
Total Elapsed Time = CPU Time + Wait Time. If a SQL statement appears in the total elapsed time area of the report this means its CPU time plus any other wait times made it pop to the top of the pile. Excessive Elapsed Time could be due to excessive CPU usage or excessive wait times.
This is the area that you need to examine and probably the one that will be reported by the users or application support. From a consumer perspective, the finer details don’t matter. The application is slow. Full stop.
In conjunction with excessive Elapsed time check to see if this piece of SQL is also a high consumer under Total CPU Time. It is normally the case. Otherwise check the wait times and Total Disk Reads. They can either indicate issues with wait times (slow disks, latch gets etc) or too much Physical IO associated with tables scans or sub-optimal indexes.  This section is a gate opener and often you will need to examine other sections.

SQL Ordered by CPU Time
When a statement appears in the Total CPU Time area this indicates it used excessive CPU cycles during its processing. Excessive CPU processing time can be caused by sorting, excessive function usage or long parse times. Indicators that you should be looking at this section for SQL tuning candidates include high CPU percentages in the service section for the service associated with this SQL (a hint, if the SQL is uppercase it probably comes from a user or application; if it is lowercase it usually comes from the internal or background processes). To reduce total CPU time, reduce sorting by using composite indexes that can cover sorting and use bind variables to reduce parse times.

SQL Ordered by Buffer Gets
Total buffer gets mean a SQL statement is reading a lot of data from the db block buffers. Generally speaking buffer gets (AKA logical IO or LIO) are OK, except when they become excessive. The old saying that you reduce the logical IO, because then the physical IO (disk read) will take care of itself holds true. LIO may  have incurred a PIO in order to get the block into the buffer in the first place. Reducing buffer gets is very important and should not be underestimated. To get a block from db block buffers, we have to latch it (i.e. in order to prevent someone from modifying the data structures we are currently reading from the buffer). Although latches are less persistent than locks, a latch is still a serialization device. Serialization devices inhibit scalability, the more you use them, the less concurrency you get. Therefore in most cases optimal buffer gets can result in improved performance. Also note that by lowering buffer gets you will require less CPU usage and less latching. |Thus to reduce excessive buffer gets, optimize SQL to use appropriate indexes and reduce full table scans. You can also look at improving the indexing strategy and consider deploying partitioning (licensed).

SQL Ordered by Disk Reads
High total disk reads mean a SQL statement is reading a lot of data from disks rather than being able to access that data from the db block buffers. High physical reads after a server reboot are expected as the cache is cold and data is fetched from the disk. However, disk reads (or physical reads) are undesirable in an OLTP system, especially when they become excessive. Excessive disk reads do cause performance issues. The usual norm is to increase the db buffer cache to allow more buffers and reduce ageing . Total disk reads are typified by high physical reads, a low buffer cache hit ratio, with high IO wait times. Higher wait times for Disk IO can be associated with a variety of reasons (busy or over saturated SAN, slower underlying storage, low capacity in HBC and other hardware causes). Statistics on IO section in AWR, plus the Operating System diagnostic tools as simple as iostatcan help in identifying these issues. To reduce excessive disk reads, consider partitioning, use indexes and look at optimizing SQL to avoid excessive full table scans.

SQL Ordered by Executions
High total executions need to be reviewed to see if they are genuine executions or loops in SQL code. I have also seen situations where autosys jobs fire duplicate codes erroneously. In general statements with high numbers of executions usually are being properly reused. However, there is always a chance of unnecessary loop in PL/SQL, Java or C#. Statements with high number of executions, high number of logical and or physical reads are candidates for review to be sure they are not being executed multiple times when a single execution would serve. If the database has excessive physical and logical reads or excessive IO wait times, then look at the SQL statements that show excessive executions and show high physical and logical reads.

Parse Calls
Whenever a statement is issued by a user or process, regardless of whether it is in the SQL pool it undergoes a parse.  As explained under Parsing, the parse can be a hard parse or a soft parse. Excessive parse calls usually go with excessive executions. If the statement is using what are known as unsafe bind variables then the statement will be reparsed each time. If the header parse ratios are low look here and in the version count areas.

SQL Ordered by Memory
Sharable Memory refers to Shared Pool memory area in SGA , hence this particular section in AWR Report states about the SQL STATEMENT CURSORS which consumed the maximum amount of the Shared Pool for their execution.
In general high values for Sharable Memory doesn’t necessary imply there is an issue It simply means that:
    - These SQL statements are big or complex and Oracle has to keep lots of information about these statements OR
    - big number of child cursors exist for those parent cursors
    - combination of 1 & 2
In case of point 2, it may be due to poor coding such as bind variables mismatch, security mismatch  or overly large SQL statements that join many tables. In a DSS or  DW environment large complex statements are normal. In an OLTP database large or complex statements are usually the result of over-normalization of the database design, attempts to use an OLTP system as a DW or simply poor coding techniques. Usually large statements will result in excessive parsing, recursion, and large CPU usage.

SQL Ordered by Version Count
High version counts are usually due to multiple identical-schema databases, unsafe bind variables, or Oracle bugs.


The SQL that is stored in the shared pool SQL area (Library cache) is reported in this section in different ways:
. SQL ordered by Buffer Gets
. SQL ordered by Physical Reads
. SQL ordered by Executions
. SQL ordered by Parse Calls

- SQL ordered by Gets:
This section reports the contents of the SQL area ordered by the number of buffer gets and can be used to identify the most CPU Heavy SQL.
- Many DBAs feel that if the data is already contained within the buffer cache the query should be efficient.  This could not be further from the truth.  Retrieving more data than needed, even from the buffer cache, requires CPU cycles and interprocess IO. Generally speaking, the cost of physical I/O is not 10,000 times more expensive.  It actually is in the neighborhood of 67 times and actually almost zero if the data is stored in the UNIX buffer cache.
- The statements of interest are those with a large number of gets per execution especially if the number of executions is high.
- High buffer gets generally correlates with heavy CPU usage

- SQL ordered by Reads:
This section reports the contents of the SQL area ordered by the number of reads from the data files and can be used to identify SQL causing IO bottlenecks which consume the following resources.
- CPU time needed to fetch unnecessary data.
- File IO resources to fetch unnecessary data.
- Buffer resources to hold unnecessary data.
- Additional CPU time to process the query once the data is retrieved into the buffer.

- SQL ordered by Executions:
This section reports the contents of the SQL area ordered by the number of query executions. It is primarily useful in identifying the most frequently used SQL within the database so that they can be monitored for efficiency.  Generally speaking, a small performance increase on a frequently used query provides greater gains than a moderate performance increase on an infrequently used query. Possible reasons for high Reads per Exec are use of unselective indexes require large numbers of blocks to be fetched where such blocks are not cached well in the buffer cache, index fragmentation, large Clustering Factor in index etc.

- SQL ordered by Parse Calls:
This section shows the number of times a statement was parsed as compared to the number of times it was executed.  One to one parse/executions may indicate that:
- Bind variables are not being used.
  The shared pool may be too small and the parse is not being retained long enough for multiple executions.
- cursor_sharing is set to exact (this should NOT be changed without considerable testing on the part of the client).

Generate Execution Plan for given SQL statement

If you have identified one or more problematic SQL statement, you may want to check the execution plan. Remember the "Old Hash Value" from the report above (1279400914), then execute the scrip to generate the execution plan.

    sqlplus perfstat/perfstat
    SQL> @?/rdbms/admin/sprepsql.sql
    Enter the Hash Value, in this example: 1279400914

    SQL Text
    ~~~~~~~~
    create table test as select * from all_objects

    Known Optimizer Plan(s) for this Old Hash Value
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Shows all known Optimizer Plans for this database instance, and the Snap Id's
    they were first found in the shared pool.  A Plan Hash Value will appear
    multiple times if the cost has changed
    -> ordered by Snap Id

      First        First          Plan
     Snap Id     Snap Time     Hash Value        Cost
    --------- --------------- ------------ ----------
            6 14 Nov 04 11:26   1386862634        52

    Plans in shared pool between Begin and End Snap Ids
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Shows the Execution Plans found in the shared pool between the begin and end
    snapshots specified.  The values for Rows, Bytes and Cost shown below are those
    which existed at the time the first-ever snapshot captured this plan - these
    values often change over time, and so may not be indicative of current values
    -> Rows indicates Cardinality, PHV is Plan Hash Value
    -> ordered by Plan Hash Value

    --------------------------------------------------------------------------------
    | Operation                      | PHV/Object Name     |  Rows | Bytes|   Cost |
    --------------------------------------------------------------------------------
    |CREATE TABLE STATEMENT          |----- 1386862634 ----|       |      |     52 |
    |LOAD AS SELECT                  |                     |       |      |        |
    | VIEW                           |                     |     1K|  216K|     44 |
    |  FILTER                        |                     |       |      |        |
    |   HASH JOIN                    |                     |     1K|  151K|     38 |
    |    TABLE ACCESS FULL           |USER$                |    29 |  464 |      2 |
    |    TABLE ACCESS FULL           |OBJ$                 |     3K|  249K|     35 |
    |   TABLE ACCESS BY INDEX ROWID  |IND$                 |     1 |    7 |      2 |
    |    INDEX UNIQUE SCAN           |I_IND1               |     1 |      |      1 |
    |   NESTED LOOPS                 |                     |     5 |  115 |     16 |
    |    INDEX RANGE SCAN            |I_OBJAUTH1           |     1 |   10 |      2 |
    |    FIXED TABLE FULL            |X$KZSRO              |     5 |   65 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   FIXED TABLE FULL             |X$KZSPR              |     1 |   26 |     14 |
    |   VIEW                         |                     |     1 |   13 |      2 |
    |    FAST DUAL                   |                     |     1 |      |      2 |
    --------------------------------------------------------------------------------

SQL ordered by Elapsed Time                  DB/Inst: ORCL/orcl  Snaps: 37-38
-> Resources reported for PL/SQL code includes the resources used by all SQL
   statements called by the code.
-> % Total DB Time is the Elapsed Time of the SQL statement divided
   into the Total Database Time multiplied by 100
-> %Total - Elapsed Time  as a percentage of Total DB time
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Captured SQL account for   81.4% of Total DB Time (s):           8,484
-> Captured PL/SQL account for   82.2% of Total DB Time (s):           8,484

        Elapsed                  Elapsed Time
        Time (s)    Executions  per Exec (s)  %Total   %CPU    %IO    SQL Id
---------------- -------------- ------------- ------ ------ ------ -------------
         4,733.3          2,047          2.31   55.8     .4   99.1 0w2qpuc6u2zsp
Module: Swingbench User Thread
BEGIN :1 := orderentry.neworder(:2 ,:3 ,:4 ); END;

         1,821.3          5,771          0.32   21.5     .1   99.7 8dq0v1mjngj7t
Module: New Order
SELECT CUSTOMER_ID, CUST_FIRST_NAME, CUST_LAST_NAME, NLS_LANGUAGE, NLS_TERRITORY
, CREDIT_LIMIT, CUST_EMAIL, ACCOUNT_MGR_ID FROM CUSTOMERS WHERE CUSTOMER_ID = :B
2 AND ROWNUM < :B1

         1,650.4          5,480          0.30   19.5     .2   99.6 0yas01u2p9ch4
Module: New Order
INSERT INTO ORDER_ITEMS(ORDER_ID, LINE_ITEM_ID, PRODUCT_ID, UNIT_PRICE, QUANTITY
) VALUES (:B4 , :B3 , :B2 , :B1 , 1)

         1,112.4          2,503          0.44   13.1     .7   98.6 147a57cxq3w5y
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseproducts(:2 ,:3 ,:4 ); END;

           931.8          6,117          0.15   11.0     .3   99.7 c13sma6rkr27c
Module: New Order
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.CATEGORY_
ID = :B3 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND INVENTORIES.WAREHO

           839.0          2,047          0.41    9.9     .2   99.4 bymb3ujkr3ubk
Module: New Order
INSERT INTO ORDERS(ORDER_ID, ORDER_DATE, CUSTOMER_ID, WAREHOUSE_ID) VALUES (ORDE
RS_SEQ.NEXTVAL + :B3 , SYSTIMESTAMP , :B2 , :B1 ) RETURNING ORDER_ID INTO :O0

           411.1            405          1.02    4.8     .3   99.5 apgb2g9q2zjh1
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseandupdateorders(:2 ,:3 ,:4 ); END;

           356.4          2,047          0.17    4.2     .2   99.6 5mddt5kt45rg3
Module: New Order
UPDATE ORDERS SET ORDER_MODE = 'online', ORDER_STATUS = FLOOR(DBMS_RANDOM.VALUE(
0, :B3 )), ORDER_TOTAL = :B2 WHERE ORDER_ID = :B1

           353.3            816          0.43    4.2     .5   98.7 dcq9a12vtcnuw
Module: Swingbench User Thread
BEGIN :1 := orderentry.newcustomer(:2 ,:3 ,:4 ,:5 ,:6 ,:7 ); END;

           345.8            816          0.42    4.1     .2   99.3 0bzhqhhj9mpaa
Module: New Customer
INSERT INTO CUSTOMERS(CUSTOMER_ID ,CUST_FIRST_NAME ,CUST_LAST_NAME ,NLS_LANGUAGE
 ,NLS_TERRITORY ,CREDIT_LIMIT ,CUST_EMAIL ,ACCOUNT_MGR_ID ) VALUES (:B9 , :B4 ,
:B3 , :B8 , :B7 , FLOOR(DBMS_RANDOM.VALUE(:B6 , :B5 )), :B4 ||'.'||:B3 ||'@'||'o
racle.com', FLOOR(DBMS_RANDOM.VALUE(:B2 , :B1 )))

           218.5            205          1.07    2.6     .2   99.7 a9gvfh5hx9u98
Module: Swingbench User Thread
BEGIN :1 := orderentry.processorders(:2 ,:3 ,:4 ); END;

           180.5            205          0.88    2.1     .1   99.8 7hk2m2702ua0g
Module: Process Orders
WITH NEED_TO_PROCESS AS (SELECT ORDER_ID, CUSTOMER_ID FROM ORDERS WHERE ORDER_ST
ATUS <= 4 AND WAREHOUSE_ID = :B1 AND ROWNUM < 10 ) SELECT O.ORDER_ID, OI.LINE_IT
EM_ID, OI.PRODUCT_ID, OI.UNIT_PRICE, OI.QUANTITY, O.ORDER_MODE, O.ORDER_STATUS,
SQL ordered by Elapsed Time                  DB/Inst: ORCL/orcl  Snaps: 37-38
-> Resources reported for PL/SQL code includes the resources used by all SQL
   statements called by the code.
-> % Total DB Time is the Elapsed Time of the SQL statement divided
   into the Total Database Time multiplied by 100
-> %Total - Elapsed Time  as a percentage of Total DB time
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Captured SQL account for   81.4% of Total DB Time (s):           8,484
-> Captured PL/SQL account for   82.2% of Total DB Time (s):           8,484

        Elapsed                  Elapsed Time
        Time (s)    Executions  per Exec (s)  %Total   %CPU    %IO    SQL Id
---------------- -------------- ------------- ------ ------ ------ -------------
O.ORDER_TOTAL, O.SALES_REP_ID, O.PROMOTION_ID, C.CUSTOMER_ID, C.CUST_FIRST_NAME,

           177.3          6,018          0.03    2.1     .3   99.7 8z3542ffmp562
Module: New Order
SELECT QUANTITY_ON_HAND FROM PRODUCT_INFORMATION P, INVENTORIES I WHERE I.PRODUC
T_ID = :B2 AND I.PRODUCT_ID = P.PRODUCT_ID AND I.WAREHOUSE_ID = :B1

           172.0            405          0.42    2.0     .1   99.4 0ruh367af7gbw
Module: Browse and Update Orders
SELECT ORDER_ID, ORDER_MODE, CUSTOMER_ID, ORDER_STATUS, ORDER_TOTAL, SALES_REP_I
D, PROMOTION_ID FROM ORDERS WHERE CUSTOMER_ID = :B2 AND ROWNUM < :B1

           144.4          7,471          0.02    1.7     .7   98.9 0y1prvxqc2ra9
Module: Browse Products
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.PRODUCT_I
D = :B2 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND ROWNUM < :B1

          -------------------------------------------------------------

SQL ordered by CPU Time                      DB/Inst: ORCL/orcl  Snaps: 37-38
-> Resources reported for PL/SQL code includes the resources used by all SQL
   statements called by the code.
-> %Total - CPU Time      as a percentage of Total DB CPU
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Captured SQL account for   53.3% of Total CPU Time (s):              50
-> Captured PL/SQL account for   88.1% of Total CPU Time (s):              50

    CPU                   CPU per           Elapsed
  Time (s)  Executions    Exec (s) %Total   Time (s)   %CPU    %IO    SQL Id
---------- ------------ ---------- ------ ---------- ------ ------ -------------
      19.8        2,047       0.01   39.4    4,733.3     .4   99.1 0w2qpuc6u2zsp
Module: Swingbench User Thread
BEGIN :1 := orderentry.neworder(:2 ,:3 ,:4 ); END;

       9.9            0        N/A   19.7       68.1   14.5   55.5 b6usrg82hwsa3
Module: DBMS_SCHEDULER
call dbms_stats.gather_database_stats_job_proc ( )

       9.2            1       9.20   18.3       14.1   65.1   26.7 2tr12b1b8uj71
Module: DBMS_SCHEDULER
MERGE /*+ dynamic_sampling(ST 4) dynamic_sampling_est_cdn(ST) */ INTO STATS_TARG
ET$ ST USING (SELECT STALENESS, OSIZE, OBJ#, TYPE#, CASE WHEN STALENESS > LOG(0.
01, NVL(LOC_STALE_PCT, :B1 )/100) THEN 128 ELSE 0 END + AFLAGS AFLAGS, STATUS, S
ID, SERIAL#, PART#, BO# FROM ( SELECT /*+ no_expand dynamic_sampling(4) dynamic_

       8.2        2,503       0.00   16.4    1,112.4     .7   98.6 147a57cxq3w5y
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseproducts(:2 ,:3 ,:4 ); END;

       3.3        5,480       0.00    6.5    1,650.4     .2   99.6 0yas01u2p9ch4
Module: New Order
INSERT INTO ORDER_ITEMS(ORDER_ID, LINE_ITEM_ID, PRODUCT_ID, UNIT_PRICE, QUANTITY
) VALUES (:B4 , :B3 , :B2 , :B1 , 1)

       2.6        6,117       0.00    5.2      931.8     .3   99.7 c13sma6rkr27c
Module: New Order
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.CATEGORY_
ID = :B3 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND INVENTORIES.WAREHO

       2.5        5,771       0.00    4.9    1,821.3     .1   99.7 8dq0v1mjngj7t
Module: New Order
SELECT CUSTOMER_ID, CUST_FIRST_NAME, CUST_LAST_NAME, NLS_LANGUAGE, NLS_TERRITORY
, CREDIT_LIMIT, CUST_EMAIL, ACCOUNT_MGR_ID FROM CUSTOMERS WHERE CUSTOMER_ID = :B
2 AND ROWNUM < :B1

       1.7          816       0.00    3.4      353.3     .5   98.7 dcq9a12vtcnuw
Module: Swingbench User Thread
BEGIN :1 := orderentry.newcustomer(:2 ,:3 ,:4 ,:5 ,:6 ,:7 ); END;

       1.7        2,047       0.00    3.3      839.0     .2   99.4 bymb3ujkr3ubk
Module: New Order
INSERT INTO ORDERS(ORDER_ID, ORDER_DATE, CUSTOMER_ID, WAREHOUSE_ID) VALUES (ORDE
RS_SEQ.NEXTVAL + :B3 , SYSTIMESTAMP , :B2 , :B1 ) RETURNING ORDER_ID INTO :O0

       1.5            1       1.51    3.0       14.5   10.4   35.8 1uk5m5qbzj1vt
Module: sqlplus@fabioprado.net (TNS V1-V3)
BEGIN dbms_workload_repository.create_snapshot; END;

       1.3            0        N/A    2.6       62.8    2.1   68.0 6mcpb06rctk0x
Module: DBMS_SCHEDULER
call dbms_space.auto_space_advisor_job_proc ( )

       1.1          405       0.00    2.3      411.1     .3   99.5 apgb2g9q2zjh1
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseandupdateorders(:2 ,:3 ,:4 ); END;

       1.0        7,471       0.00    2.1      144.4     .7   98.9 0y1prvxqc2ra9
Module: Browse Products
SQL ordered by CPU Time                      DB/Inst: ORCL/orcl  Snaps: 37-38
-> Resources reported for PL/SQL code includes the resources used by all SQL
   statements called by the code.
-> %Total - CPU Time      as a percentage of Total DB CPU
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Captured SQL account for   53.3% of Total CPU Time (s):              50
-> Captured PL/SQL account for   88.1% of Total CPU Time (s):              50

    CPU                   CPU per           Elapsed
  Time (s)  Executions    Exec (s) %Total   Time (s)   %CPU    %IO    SQL Id
---------- ------------ ---------- ------ ---------- ------ ------ -------------
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.PRODUCT_I
D = :B2 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND ROWNUM < :B1

       0.8        2,047       0.00    1.6      356.4     .2   99.6 5mddt5kt45rg3
Module: New Order
UPDATE ORDERS SET ORDER_MODE = 'online', ORDER_STATUS = FLOOR(DBMS_RANDOM.VALUE(
0, :B3 )), ORDER_TOTAL = :B2 WHERE ORDER_ID = :B1

       0.7          816       0.00    1.4      345.8     .2   99.3 0bzhqhhj9mpaa
Module: New Customer
INSERT INTO CUSTOMERS(CUSTOMER_ID ,CUST_FIRST_NAME ,CUST_LAST_NAME ,NLS_LANGUAGE
 ,NLS_TERRITORY ,CREDIT_LIMIT ,CUST_EMAIL ,ACCOUNT_MGR_ID ) VALUES (:B9 , :B4 ,
:B3 , :B8 , :B7 , FLOOR(DBMS_RANDOM.VALUE(:B6 , :B5 )), :B4 ||'.'||:B3 ||'@'||'o
racle.com', FLOOR(DBMS_RANDOM.VALUE(:B2 , :B1 )))

       0.6        6,018       0.00    1.1      177.3     .3   99.7 8z3542ffmp562
Module: New Order
SELECT QUANTITY_ON_HAND FROM PRODUCT_INFORMATION P, INVENTORIES I WHERE I.PRODUC
T_ID = :B2 AND I.PRODUCT_ID = P.PRODUCT_ID AND I.WAREHOUSE_ID = :B1

       0.5       14,233       0.00    1.0        0.6   86.2     .0 7sx5p1ug5ag12
Module: DBMS_SCHEDULER
SELECT SPARE4 FROM SYS.OPTSTAT_HIST_CONTROL$ WHERE SNAME = :B1

       0.5          205       0.00    1.0      218.5     .2   99.7 a9gvfh5hx9u98
Module: Swingbench User Thread
BEGIN :1 := orderentry.processorders(:2 ,:3 ,:4 ); END;

          -------------------------------------------------------------

SQL ordered by User I/O Wait Time            DB/Inst: ORCL/orcl  Snaps: 37-38
-> Resources reported for PL/SQL code includes the resources used by all SQL
   statements called by the code.
-> %Total - User I/O Time as a percentage of Total User I/O Wait time
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Captured SQL account for   99.8% of Total User I/O Wait Time (s):           6
-> Captured PL/SQL account for   99.9% of Total User I/O Wait Time (s):

  User I/O                UIO per           Elapsed
  Time (s)  Executions    Exec (s) %Total   Time (s)   %CPU    %IO    SQL Id
---------- ------------ ---------- ------ ---------- ------ ------ -------------
   4,692.9        2,047       2.29   68.4    4,733.3     .4   99.1 0w2qpuc6u2zsp
Module: Swingbench User Thread
BEGIN :1 := orderentry.neworder(:2 ,:3 ,:4 ); END;

   1,816.0        5,771       0.31   26.5    1,821.3     .1   99.7 8dq0v1mjngj7t
Module: New Order
SELECT CUSTOMER_ID, CUST_FIRST_NAME, CUST_LAST_NAME, NLS_LANGUAGE, NLS_TERRITORY
, CREDIT_LIMIT, CUST_EMAIL, ACCOUNT_MGR_ID FROM CUSTOMERS WHERE CUSTOMER_ID = :B
2 AND ROWNUM < :B1

   1,643.7        5,480       0.30   24.0    1,650.4     .2   99.6 0yas01u2p9ch4
Module: New Order
INSERT INTO ORDER_ITEMS(ORDER_ID, LINE_ITEM_ID, PRODUCT_ID, UNIT_PRICE, QUANTITY
) VALUES (:B4 , :B3 , :B2 , :B1 , 1)

   1,096.4        2,503       0.44   16.0    1,112.4     .7   98.6 147a57cxq3w5y
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseproducts(:2 ,:3 ,:4 ); END;

     929.4        6,117       0.15   13.5      931.8     .3   99.7 c13sma6rkr27c
Module: New Order
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.CATEGORY_
ID = :B3 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND INVENTORIES.WAREHO

     834.0        2,047       0.41   12.2      839.0     .2   99.4 bymb3ujkr3ubk
Module: New Order
INSERT INTO ORDERS(ORDER_ID, ORDER_DATE, CUSTOMER_ID, WAREHOUSE_ID) VALUES (ORDE
RS_SEQ.NEXTVAL + :B3 , SYSTIMESTAMP , :B2 , :B1 ) RETURNING ORDER_ID INTO :O0

     409.1          405       1.01    6.0      411.1     .3   99.5 apgb2g9q2zjh1
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseandupdateorders(:2 ,:3 ,:4 ); END;

     355.0        2,047       0.17    5.2      356.4     .2   99.6 5mddt5kt45rg3
Module: New Order
UPDATE ORDERS SET ORDER_MODE = 'online', ORDER_STATUS = FLOOR(DBMS_RANDOM.VALUE(
0, :B3 )), ORDER_TOTAL = :B2 WHERE ORDER_ID = :B1

     348.7          816       0.43    5.1      353.3     .5   98.7 dcq9a12vtcnuw
Module: Swingbench User Thread
BEGIN :1 := orderentry.newcustomer(:2 ,:3 ,:4 ,:5 ,:6 ,:7 ); END;

     343.2          816       0.42    5.0      345.8     .2   99.3 0bzhqhhj9mpaa
Module: New Customer
INSERT INTO CUSTOMERS(CUSTOMER_ID ,CUST_FIRST_NAME ,CUST_LAST_NAME ,NLS_LANGUAGE
 ,NLS_TERRITORY ,CREDIT_LIMIT ,CUST_EMAIL ,ACCOUNT_MGR_ID ) VALUES (:B9 , :B4 ,
:B3 , :B8 , :B7 , FLOOR(DBMS_RANDOM.VALUE(:B6 , :B5 )), :B4 ||'.'||:B3 ||'@'||'o
racle.com', FLOOR(DBMS_RANDOM.VALUE(:B2 , :B1 )))

     217.8          205       1.06    3.2      218.5     .2   99.7 a9gvfh5hx9u98
Module: Swingbench User Thread
BEGIN :1 := orderentry.processorders(:2 ,:3 ,:4 ); END;

     180.1          205       0.88    2.6      180.5     .1   99.8 7hk2m2702ua0g
Module: Process Orders
WITH NEED_TO_PROCESS AS (SELECT ORDER_ID, CUSTOMER_ID FROM ORDERS WHERE ORDER_ST
ATUS <= 4 AND WAREHOUSE_ID = :B1 AND ROWNUM < 10 ) SELECT O.ORDER_ID, OI.LINE_IT
EM_ID, OI.PRODUCT_ID, OI.UNIT_PRICE, OI.QUANTITY, O.ORDER_MODE, O.ORDER_STATUS,
SQL ordered by User I/O Wait Time            DB/Inst: ORCL/orcl  Snaps: 37-38
-> Resources reported for PL/SQL code includes the resources used by all SQL
   statements called by the code.
-> %Total - User I/O Time as a percentage of Total User I/O Wait time
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Captured SQL account for   99.8% of Total User I/O Wait Time (s):           6
-> Captured PL/SQL account for   99.9% of Total User I/O Wait Time (s):

  User I/O                UIO per           Elapsed
  Time (s)  Executions    Exec (s) %Total   Time (s)   %CPU    %IO    SQL Id
---------- ------------ ---------- ------ ---------- ------ ------ -------------
O.ORDER_TOTAL, O.SALES_REP_ID, O.PROMOTION_ID, C.CUSTOMER_ID, C.CUST_FIRST_NAME,

     176.8        6,018       0.03    2.6      177.3     .3   99.7 8z3542ffmp562
Module: New Order
SELECT QUANTITY_ON_HAND FROM PRODUCT_INFORMATION P, INVENTORIES I WHERE I.PRODUC
T_ID = :B2 AND I.PRODUCT_ID = P.PRODUCT_ID AND I.WAREHOUSE_ID = :B1

     171.0          405       0.42    2.5      172.0     .1   99.4 0ruh367af7gbw
Module: Browse and Update Orders
SELECT ORDER_ID, ORDER_MODE, CUSTOMER_ID, ORDER_STATUS, ORDER_TOTAL, SALES_REP_I
D, PROMOTION_ID FROM ORDERS WHERE CUSTOMER_ID = :B2 AND ROWNUM < :B1

     142.9        7,471       0.02    2.1      144.4     .7   98.9 0y1prvxqc2ra9
Module: Browse Products
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.PRODUCT_I
D = :B2 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND ROWNUM < :B1

          -------------------------------------------------------------

SQL ordered by Gets                          DB/Inst: ORCL/orcl  Snaps: 37-38
-> Resources reported for PL/SQL code includes the resources used by all SQL
   statements called by the code.
-> %Total - Buffer Gets   as a percentage of Total Buffer Gets
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Total Buffer Gets:         731,220
-> Captured SQL account for  101.1% of Total

     Buffer                 Gets              Elapsed
      Gets   Executions   per Exec   %Total   Time (s)   %CPU    %IO    SQL Id
----------- ----------- ------------ ------ ---------- ------ ------ -----------
    433,407       2,047        211.7   59.3    4,733.3     .4   99.1 0w2qpuc6u2z
Module: Swingbench User Thread
BEGIN :1 := orderentry.neworder(:2 ,:3 ,:4 ); END;

    182,986       6,117         29.9   25.0      931.8     .3   99.7 c13sma6rkr2
Module: New Order
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.CATEGORY_
ID = :B3 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND INVENTORIES.WAREHO

    100,729       5,480         18.4   13.8    1,650.4     .2   99.6 0yas01u2p9c
Module: New Order
INSERT INTO ORDER_ITEMS(ORDER_ID, LINE_ITEM_ID, PRODUCT_ID, UNIT_PRICE, QUANTITY
) VALUES (:B4 , :B3 , :B2 , :B1 , 1)

     98,828           0          N/A   13.5       68.1   14.5   55.5 b6usrg82hws
Module: DBMS_SCHEDULER
call dbms_stats.gather_database_stats_job_proc ( )

     95,493       2,503         38.2   13.1    1,112.4     .7   98.6 147a57cxq3w
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseproducts(:2 ,:3 ,:4 ); END;

     81,977           1     81,977.0   11.2       14.1   65.1   26.7 2tr12b1b8uj
Module: DBMS_SCHEDULER
MERGE /*+ dynamic_sampling(ST 4) dynamic_sampling_est_cdn(ST) */ INTO STATS_TARG
ET$ ST USING (SELECT STALENESS, OSIZE, OBJ#, TYPE#, CASE WHEN STALENESS > LOG(0.
01, NVL(LOC_STALE_PCT, :B1 )/100) THEN 128 ELSE 0 END + AFLAGS AFLAGS, STATUS, S
ID, SERIAL#, PART#, BO# FROM ( SELECT /*+ no_expand dynamic_sampling(4) dynamic_

     67,944       7,471          9.1    9.3      144.4     .7   98.9 0y1prvxqc2r
Module: Browse Products
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.PRODUCT_I
D = :B2 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND ROWNUM < :B1

     45,960       2,047         22.5    6.3      839.0     .2   99.4 bymb3ujkr3u
Module: New Order
INSERT INTO ORDERS(ORDER_ID, ORDER_DATE, CUSTOMER_ID, WAREHOUSE_ID) VALUES (ORDE
RS_SEQ.NEXTVAL + :B3 , SYSTIMESTAMP , :B2 , :B1 ) RETURNING ORDER_ID INTO :O0

     42,719      14,233          3.0    5.8        0.6   86.2     .0 7sx5p1ug5ag
Module: DBMS_SCHEDULER
SELECT SPARE4 FROM SYS.OPTSTAT_HIST_CONTROL$ WHERE SNAME = :B1

     41,074           0          N/A    5.6       62.8    2.1   68.0 6mcpb06rctk
Module: DBMS_SCHEDULER
call dbms_space.auto_space_advisor_job_proc ( )

     34,567       5,771          6.0    4.7       38.0    1.3   91.7 5raw2bzx227
Module: New Order
INSERT INTO LOGON VALUES (:B2 , :B1 )

     34,500       6,018          5.7    4.7      177.3     .3   99.7 8z3542ffmp5
Module: New Order
SELECT QUANTITY_ON_HAND FROM PRODUCT_INFORMATION P, INVENTORIES I WHERE I.PRODUC
T_ID = :B2 AND I.PRODUCT_ID = P.PRODUCT_ID AND I.WAREHOUSE_ID = :B1

SQL ordered by Gets                          DB/Inst: ORCL/orcl  Snaps: 37-38
-> Resources reported for PL/SQL code includes the resources used by all SQL
   statements called by the code.
-> %Total - Buffer Gets   as a percentage of Total Buffer Gets
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Total Buffer Gets:         731,220
-> Captured SQL account for  101.1% of Total

     Buffer                 Gets              Elapsed
      Gets   Executions   per Exec   %Total   Time (s)   %CPU    %IO    SQL Id
----------- ----------- ------------ ------ ---------- ------ ------ -----------
     28,352         816         34.7    3.9      353.3     .5   98.7 dcq9a12vtcn
Module: Swingbench User Thread
BEGIN :1 := orderentry.newcustomer(:2 ,:3 ,:4 ,:5 ,:6 ,:7 ); END;

     23,086       5,771          4.0    3.2    1,821.3     .1   99.7 8dq0v1mjngj
Module: New Order
SELECT CUSTOMER_ID, CUST_FIRST_NAME, CUST_LAST_NAME, NLS_LANGUAGE, NLS_TERRITORY
, CREDIT_LIMIT, CUST_EMAIL, ACCOUNT_MGR_ID FROM CUSTOMERS WHERE CUSTOMER_ID = :B
2 AND ROWNUM < :B1

     22,731       2,047         11.1    3.1      356.4     .2   99.6 5mddt5kt45r
Module: New Order
UPDATE ORDERS SET ORDER_MODE = 'online', ORDER_STATUS = FLOOR(DBMS_RANDOM.VALUE(
0, :B3 )), ORDER_TOTAL = :B2 WHERE ORDER_ID = :B1

     22,139       1,964         11.3    3.0        1.2   15.1   28.4 7r7636982at
Module: New Order
UPDATE INVENTORIES SET QUANTITY_ON_HAND = QUANTITY_ON_HAND - :B1 WHERE PRODUCT_I
D = :B3 AND WAREHOUSE_ID = :B2

     18,531         816         22.7    2.5      345.8     .2   99.3 0bzhqhhj9mp
Module: New Customer
INSERT INTO CUSTOMERS(CUSTOMER_ID ,CUST_FIRST_NAME ,CUST_LAST_NAME ,NLS_LANGUAGE
 ,NLS_TERRITORY ,CREDIT_LIMIT ,CUST_EMAIL ,ACCOUNT_MGR_ID ) VALUES (:B9 , :B4 ,
:B3 , :B8 , :B7 , FLOOR(DBMS_RANDOM.VALUE(:B6 , :B5 )), :B4 ||'.'||:B3 ||'@'||'o
racle.com', FLOOR(DBMS_RANDOM.VALUE(:B2 , :B1 )))

     14,220      14,220          1.0    1.9        0.4  100.3     .0 cn39cg7kr98
Module: DBMS_SCHEDULER
SELECT P.VALCHAR FROM SYS.OPTSTAT_USER_PREFS$ P WHERE P.OBJ#=:B2 AND P.PNAME=:B1


     10,820           1     10,820.0    1.5        5.2    2.8   96.4 01xv155rhts
Module: DBMS_SCHEDULER
SELECT COUNT(*) FROM SYS_UNCOMPRESSED_SEGS WHERE TOTAL_INDEXES >= 3 AND SEGSIZE
> 10485760

     10,114           1     10,114.0    1.4       14.5   10.4   35.8 1uk5m5qbzj1
Module: sqlplus@fabioprado.net (TNS V1-V3)
BEGIN dbms_workload_repository.create_snapshot; END;

      7,837          38        206.2    1.1       10.1    1.3   68.4 8bmx9xzmx4u
Module: DBMS_SCHEDULER
SELECT OWNER, SEGMENT_NAME, PARTITION_NAME, SEGMENT_TYPE, TABLESPACE_NAME, TABLE
SPACE_ID FROM SYS_DBA_SEGS WHERE SEGMENT_OBJD = :B1 AND SEGMENT_TYPE <> 'ROLLBAC
K' AND SEGMENT_TYPE <> 'TYPE2 UNDO' AND SEGMENT_TYPE <> 'DEFERRED ROLLBACK' AND
SEGMENT_TYPE <> 'TEMPORARY' AND SEGMENT_TYPE <> 'CACHE' AND SEGMENT_TYPE <> 'SPA

      7,797         405         19.3    1.1      411.1     .3   99.5 apgb2g9q2zj
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseandupdateorders(:2 ,:3 ,:4 ); END;

          -------------------------------------------------------------

SQL ordered by Reads                         DB/Inst: ORCL/orcl  Snaps: 37-38
-> %Total - Physical Reads as a percentage of Total Disk Reads
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Total Disk Reads:          47,336
-> Captured SQL account for   97.4% of Total

   Physical              Reads              Elapsed
      Reads  Executions per Exec   %Total   Time (s)   %CPU    %IO    SQL Id
----------- ----------- ---------- ------ ---------- ------ ------ -------------
     30,833       2,047       15.1   65.1    4,733.3     .4   99.1 0w2qpuc6u2zsp
Module: Swingbench User Thread
BEGIN :1 := orderentry.neworder(:2 ,:3 ,:4 ); END;

      9,192       5,480        1.7   19.4    1,650.4     .2   99.6 0yas01u2p9ch4
Module: New Order
INSERT INTO ORDER_ITEMS(ORDER_ID, LINE_ITEM_ID, PRODUCT_ID, UNIT_PRICE, QUANTITY
) VALUES (:B4 , :B3 , :B2 , :B1 , 1)

      8,268       2,047        4.0   17.5      839.0     .2   99.4 bymb3ujkr3ubk
Module: New Order
INSERT INTO ORDERS(ORDER_ID, ORDER_DATE, CUSTOMER_ID, WAREHOUSE_ID) VALUES (ORDE
RS_SEQ.NEXTVAL + :B3 , SYSTIMESTAMP , :B2 , :B1 ) RETURNING ORDER_ID INTO :O0

      7,810       5,771        1.4   16.5    1,821.3     .1   99.7 8dq0v1mjngj7t
Module: New Order
SELECT CUSTOMER_ID, CUST_FIRST_NAME, CUST_LAST_NAME, NLS_LANGUAGE, NLS_TERRITORY
, CREDIT_LIMIT, CUST_EMAIL, ACCOUNT_MGR_ID FROM CUSTOMERS WHERE CUSTOMER_ID = :B
2 AND ROWNUM < :B1

      7,536       6,117        1.2   15.9      931.8     .3   99.7 c13sma6rkr27c
Module: New Order
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.CATEGORY_
ID = :B3 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND INVENTORIES.WAREHO

      6,081         405       15.0   12.8      411.1     .3   99.5 apgb2g9q2zjh1
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseandupdateorders(:2 ,:3 ,:4 ); END;

      4,986         405       12.3   10.5      172.0     .1   99.4 0ruh367af7gbw
Module: Browse and Update Orders
SELECT ORDER_ID, ORDER_MODE, CUSTOMER_ID, ORDER_STATUS, ORDER_TOTAL, SALES_REP_I
D, PROMOTION_ID FROM ORDERS WHERE CUSTOMER_ID = :B2 AND ROWNUM < :B1

      4,977       2,503        2.0   10.5    1,112.4     .7   98.6 147a57cxq3w5y
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseproducts(:2 ,:3 ,:4 ); END;

      1,532           0        N/A    3.2       68.1   14.5   55.5 b6usrg82hwsa3
Module: DBMS_SCHEDULER
call dbms_stats.gather_database_stats_job_proc ( )

      1,495         205        7.3    3.2      218.5     .2   99.7 a9gvfh5hx9u98
Module: Swingbench User Thread
BEGIN :1 := orderentry.processorders(:2 ,:3 ,:4 ); END;

      1,454         816        1.8    3.1      353.3     .5   98.7 dcq9a12vtcnuw
Module: Swingbench User Thread
BEGIN :1 := orderentry.newcustomer(:2 ,:3 ,:4 ,:5 ,:6 ,:7 ); END;

      1,427         816        1.7    3.0      345.8     .2   99.3 0bzhqhhj9mpaa
Module: New Customer
INSERT INTO CUSTOMERS(CUSTOMER_ID ,CUST_FIRST_NAME ,CUST_LAST_NAME ,NLS_LANGUAGE
 ,NLS_TERRITORY ,CREDIT_LIMIT ,CUST_EMAIL ,ACCOUNT_MGR_ID ) VALUES (:B9 , :B4 ,
:B3 , :B8 , :B7 , FLOOR(DBMS_RANDOM.VALUE(:B6 , :B5 )), :B4 ||'.'||:B3 ||'@'||'o
racle.com', FLOOR(DBMS_RANDOM.VALUE(:B2 , :B1 )))

      1,403       2,047        0.7    3.0      356.4     .2   99.6 5mddt5kt45rg3
SQL ordered by Reads                         DB/Inst: ORCL/orcl  Snaps: 37-38
-> %Total - Physical Reads as a percentage of Total Disk Reads
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Total Disk Reads:          47,336
-> Captured SQL account for   97.4% of Total

   Physical              Reads              Elapsed
      Reads  Executions per Exec   %Total   Time (s)   %CPU    %IO    SQL Id
----------- ----------- ---------- ------ ---------- ------ ------ -------------
Module: New Order
UPDATE ORDERS SET ORDER_MODE = 'online', ORDER_STATUS = FLOOR(DBMS_RANDOM.VALUE(
0, :B3 )), ORDER_TOTAL = :B2 WHERE ORDER_ID = :B1

      1,297         205        6.3    2.7      180.5     .1   99.8 7hk2m2702ua0g
Module: Process Orders
WITH NEED_TO_PROCESS AS (SELECT ORDER_ID, CUSTOMER_ID FROM ORDERS WHERE ORDER_ST
ATUS <= 4 AND WAREHOUSE_ID = :B1 AND ROWNUM < 10 ) SELECT O.ORDER_ID, OI.LINE_IT
EM_ID, OI.PRODUCT_ID, OI.UNIT_PRICE, OI.QUANTITY, O.ORDER_MODE, O.ORDER_STATUS,
O.ORDER_TOTAL, O.SALES_REP_ID, O.PROMOTION_ID, C.CUSTOMER_ID, C.CUST_FIRST_NAME,

      1,137       6,018        0.2    2.4      177.3     .3   99.7 8z3542ffmp562
Module: New Order
SELECT QUANTITY_ON_HAND FROM PRODUCT_INFORMATION P, INVENTORIES I WHERE I.PRODUC
T_ID = :B2 AND I.PRODUCT_ID = P.PRODUCT_ID AND I.WAREHOUSE_ID = :B1

        959       7,471        0.1    2.0      144.4     .7   98.9 0y1prvxqc2ra9
Module: Browse Products
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.PRODUCT_I
D = :B2 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND ROWNUM < :B1

        870           0        N/A    1.8       62.8    2.1   68.0 6mcpb06rctk0x
Module: DBMS_SCHEDULER
call dbms_space.auto_space_advisor_job_proc ( )

          -------------------------------------------------------------

SQL ordered by Physical Reads (UnOptimized)  DB/Inst: ORCL/orcl  Snaps: 37-38
-> UnOptimized Read Reqs = Physical Read Reqts - Optimized Read Reqs
-> %Opt   - Optimized Reads as percentage of SQL Read Requests
-> %Total - UnOptimized Read Reqs as a percentage of Total UnOptimized Read Reqs
-> Total Physical Read Requests:          38,018
-> Captured SQL account for   99.4% of Total
-> Total UnOptimized Read Requests:          38,018
-> Captured SQL account for   99.4% of Total
-> Total Optimized Read Requests:               1
-> Captured SQL account for    0.0% of Total

UnOptimized   Physical              UnOptimized
  Read Reqs   Read Reqs Executions Reqs per Exe   %Opt %Total    SQL Id
----------- ----------- ---------- ------------ ------ ------ -------------
     27,573      27,573      2,047         13.5    0.0   72.5 0w2qpuc6u2zsp
Module: Swingbench User Thread
BEGIN :1 := orderentry.neworder(:2 ,:3 ,:4 ); END;

      9,192       9,192      5,480          1.7    0.0   24.2 0yas01u2p9ch4
Module: New Order
INSERT INTO ORDER_ITEMS(ORDER_ID, LINE_ITEM_ID, PRODUCT_ID, UNIT_PRICE, QUANTITY
) VALUES (:B4 , :B3 , :B2 , :B1 , 1)

      7,810       7,810      5,771          1.4    0.0   20.5 8dq0v1mjngj7t
Module: New Order
SELECT CUSTOMER_ID, CUST_FIRST_NAME, CUST_LAST_NAME, NLS_LANGUAGE, NLS_TERRITORY
, CREDIT_LIMIT, CUST_EMAIL, ACCOUNT_MGR_ID FROM CUSTOMERS WHERE CUSTOMER_ID = :B
2 AND ROWNUM < :B1

      7,536       7,536      6,117          1.2    0.0   19.8 c13sma6rkr27c
Module: New Order
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.CATEGORY_
ID = :B3 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND INVENTORIES.WAREHO

      5,007       5,007      2,047          2.4    0.0   13.2 bymb3ujkr3ubk
Module: New Order
INSERT INTO ORDERS(ORDER_ID, ORDER_DATE, CUSTOMER_ID, WAREHOUSE_ID) VALUES (ORDE
RS_SEQ.NEXTVAL + :B3 , SYSTIMESTAMP , :B2 , :B1 ) RETURNING ORDER_ID INTO :O0

      4,977       4,977      2,503          2.0    0.0   13.1 147a57cxq3w5y
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseproducts(:2 ,:3 ,:4 ); END;

      1,839       1,839        405          4.5    0.0    4.8 apgb2g9q2zjh1
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseandupdateorders(:2 ,:3 ,:4 ); END;

      1,454       1,454        816          1.8    0.0    3.8 dcq9a12vtcnuw
Module: Swingbench User Thread
BEGIN :1 := orderentry.newcustomer(:2 ,:3 ,:4 ,:5 ,:6 ,:7 ); END;

      1,427       1,427        816          1.7    0.0    3.8 0bzhqhhj9mpaa
Module: New Customer
INSERT INTO CUSTOMERS(CUSTOMER_ID ,CUST_FIRST_NAME ,CUST_LAST_NAME ,NLS_LANGUAGE
 ,NLS_TERRITORY ,CREDIT_LIMIT ,CUST_EMAIL ,ACCOUNT_MGR_ID ) VALUES (:B9 , :B4 ,
:B3 , :B8 , :B7 , FLOOR(DBMS_RANDOM.VALUE(:B6 , :B5 )), :B4 ||'.'||:B3 ||'@'||'o
racle.com', FLOOR(DBMS_RANDOM.VALUE(:B2 , :B1 )))

      1,403       1,403      2,047          0.7    0.0    3.7 5mddt5kt45rg3
Module: New Order
UPDATE ORDERS SET ORDER_MODE = 'online', ORDER_STATUS = FLOOR(DBMS_RANDOM.VALUE(
0, :B3 )), ORDER_TOTAL = :B2 WHERE ORDER_ID = :B1

      1,137       1,137      6,018          0.2    0.0    3.0 8z3542ffmp562
Module: New Order
SELECT QUANTITY_ON_HAND FROM PRODUCT_INFORMATION P, INVENTORIES I WHERE I.PRODUC
T_ID = :B2 AND I.PRODUCT_ID = P.PRODUCT_ID AND I.WAREHOUSE_ID = :B1

      1,054       1,054        205          5.1    0.0    2.8 a9gvfh5hx9u98
Module: Swingbench User Thread
BEGIN :1 := orderentry.processorders(:2 ,:3 ,:4 ); END;

SQL ordered by Physical Reads (UnOptimized)  DB/Inst: ORCL/orcl  Snaps: 37-38
-> UnOptimized Read Reqs = Physical Read Reqts - Optimized Read Reqs
-> %Opt   - Optimized Reads as percentage of SQL Read Requests
-> %Total - UnOptimized Read Reqs as a percentage of Total UnOptimized Read Reqs
-> Total Physical Read Requests:          38,018
-> Captured SQL account for   99.4% of Total
-> Total UnOptimized Read Requests:          38,018
-> Captured SQL account for   99.4% of Total
-> Total Optimized Read Requests:               1
-> Captured SQL account for    0.0% of Total

UnOptimized   Physical              UnOptimized
  Read Reqs   Read Reqs Executions Reqs per Exe   %Opt %Total    SQL Id
----------- ----------- ---------- ------------ ------ ------ -------------
        959         959      7,471          0.1    0.0    2.5 0y1prvxqc2ra9
Module: Browse Products
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.PRODUCT_I
D = :B2 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND ROWNUM < :B1

        856         856        205          4.2    0.0    2.3 7hk2m2702ua0g
Module: Process Orders
WITH NEED_TO_PROCESS AS (SELECT ORDER_ID, CUSTOMER_ID FROM ORDERS WHERE ORDER_ST
ATUS <= 4 AND WAREHOUSE_ID = :B1 AND ROWNUM < 10 ) SELECT O.ORDER_ID, OI.LINE_IT
EM_ID, OI.PRODUCT_ID, OI.UNIT_PRICE, OI.QUANTITY, O.ORDER_MODE, O.ORDER_STATUS,
O.ORDER_TOTAL, O.SALES_REP_ID, O.PROMOTION_ID, C.CUSTOMER_ID, C.CUST_FIRST_NAME,

        744         744        405          1.8    0.0    2.0 0ruh367af7gbw
Module: Browse and Update Orders
SELECT ORDER_ID, ORDER_MODE, CUSTOMER_ID, ORDER_STATUS, ORDER_TOTAL, SALES_REP_I
D, PROMOTION_ID FROM ORDERS WHERE CUSTOMER_ID = :B2 AND ROWNUM < :B1

        527         527          0          N/A    0.0    1.4 6mcpb06rctk0x
Module: DBMS_SCHEDULER
call dbms_space.auto_space_advisor_job_proc ( )

        505         505          0          N/A    0.0    1.3 b6usrg82hwsa3
Module: DBMS_SCHEDULER
call dbms_stats.gather_database_stats_job_proc ( )

          -------------------------------------------------------------

SQL ordered by Executions                    DB/Inst: ORCL/orcl  Snaps: 37-38
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Total Executions:          92,773
-> Captured SQL account for   88.6% of Total

                                              Elapsed
 Executions   Rows Processed  Rows per Exec   Time (s)   %CPU    %IO    SQL Id
------------ --------------- -------------- ---------- ------ ------ -----------
      14,233          14,233            1.0        0.6   86.2     .0 7sx5p1ug5ag
Module: DBMS_SCHEDULER
SELECT SPARE4 FROM SYS.OPTSTAT_HIST_CONTROL$ WHERE SNAME = :B1

      14,220               0            0.0        0.4  100.3     .0 cn39cg7kr98
Module: DBMS_SCHEDULER
SELECT P.VALCHAR FROM SYS.OPTSTAT_USER_PREFS$ P WHERE P.OBJ#=:B2 AND P.PNAME=:B1


       7,471         104,608           14.0      144.4     .7   98.9 0y1prvxqc2r
Module: Browse Products
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.PRODUCT_I
D = :B2 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND ROWNUM < :B1

       6,117          27,422            4.5      931.8     .3   99.7 c13sma6rkr2
Module: New Order
SELECT PRODUCTS.PRODUCT_ID, PRODUCT_NAME, PRODUCT_DESCRIPTION, CATEGORY_ID, WEIG
HT_CLASS, WARRANTY_PERIOD, SUPPLIER_ID, PRODUCT_STATUS, LIST_PRICE, MIN_PRICE, C
ATALOG_URL, QUANTITY_ON_HAND FROM PRODUCTS, INVENTORIES WHERE PRODUCTS.CATEGORY_
ID = :B3 AND INVENTORIES.PRODUCT_ID = PRODUCTS.PRODUCT_ID AND INVENTORIES.WAREHO

       6,018           5,480            0.9      177.3     .3   99.7 8z3542ffmp5
Module: New Order
SELECT QUANTITY_ON_HAND FROM PRODUCT_INFORMATION P, INVENTORIES I WHERE I.PRODUC
T_ID = :B2 AND I.PRODUCT_ID = P.PRODUCT_ID AND I.WAREHOUSE_ID = :B1

       5,771           5,771            1.0       38.0    1.3   91.7 5raw2bzx227
Module: New Order
INSERT INTO LOGON VALUES (:B2 , :B1 )

       5,771           5,771            1.0    1,821.3     .1   99.7 8dq0v1mjngj
Module: New Order
SELECT CUSTOMER_ID, CUST_FIRST_NAME, CUST_LAST_NAME, NLS_LANGUAGE, NLS_TERRITORY
, CREDIT_LIMIT, CUST_EMAIL, ACCOUNT_MGR_ID FROM CUSTOMERS WHERE CUSTOMER_ID = :B
2 AND ROWNUM < :B1

       5,768           5,771            1.0        0.3   52.6     .0 c749bc43qqf
Module: New Order
SELECT SYSDATE FROM DUAL

       5,480           5,480            1.0    1,650.4     .2   99.6 0yas01u2p9c
Module: New Order
INSERT INTO ORDER_ITEMS(ORDER_ID, LINE_ITEM_ID, PRODUCT_ID, UNIT_PRICE, QUANTITY
) VALUES (:B4 , :B3 , :B2 , :B1 , 1)

       2,503           2,503            1.0    1,112.4     .7   98.6 147a57cxq3w
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseproducts(:2 ,:3 ,:4 ); END;

       2,047           2,047            1.0    4,733.3     .4   99.1 0w2qpuc6u2z
Module: Swingbench User Thread
BEGIN :1 := orderentry.neworder(:2 ,:3 ,:4 ); END;

       2,047           2,047            1.0      356.4     .2   99.6 5mddt5kt45r
Module: New Order
UPDATE ORDERS SET ORDER_MODE = 'online', ORDER_STATUS = FLOOR(DBMS_RANDOM.VALUE(
0, :B3 )), ORDER_TOTAL = :B2 WHERE ORDER_ID = :B1

SQL ordered by Executions                    DB/Inst: ORCL/orcl  Snaps: 37-38
-> %CPU   - CPU Time      as a percentage of Elapsed Time
-> %IO    - User I/O Time as a percentage of Elapsed Time
-> Total Executions:          92,773
-> Captured SQL account for   88.6% of Total

                                              Elapsed
 Executions   Rows Processed  Rows per Exec   Time (s)   %CPU    %IO    SQL Id
------------ --------------- -------------- ---------- ------ ------ -----------
       2,047           2,047            1.0      839.0     .2   99.4 bymb3ujkr3u
Module: New Order
INSERT INTO ORDERS(ORDER_ID, ORDER_DATE, CUSTOMER_ID, WAREHOUSE_ID) VALUES (ORDE
RS_SEQ.NEXTVAL + :B3 , SYSTIMESTAMP , :B2 , :B1 ) RETURNING ORDER_ID INTO :O0

       1,964           5,480            2.8        1.2   15.1   28.4 7r7636982at
Module: New Order
UPDATE INVENTORIES SET QUANTITY_ON_HAND = QUANTITY_ON_HAND - :B1 WHERE PRODUCT_I
D = :B3 AND WAREHOUSE_ID = :B2

          -------------------------------------------------------------

SQL ordered by Parse Calls                   DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total Parse Calls:          17,837
-> Captured SQL account for   22.5% of Total

                            % Total
 Parse Calls  Executions     Parses    SQL Id
------------ ------------ --------- -------------
       2,503        2,503     14.03 147a57cxq3w5y
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseproducts(:2 ,:3 ,:4 ); END;

       2,047        2,047     11.48 0w2qpuc6u2zsp
Module: Swingbench User Thread
BEGIN :1 := orderentry.neworder(:2 ,:3 ,:4 ); END;

         816          816      4.57 dcq9a12vtcnuw
Module: Swingbench User Thread
BEGIN :1 := orderentry.newcustomer(:2 ,:3 ,:4 ,:5 ,:6 ,:7 ); END;

         405          405      2.27 apgb2g9q2zjh1
Module: Swingbench User Thread
BEGIN :1 := orderentry.browseandupdateorders(:2 ,:3 ,:4 ); END;

         386          386      2.16 350f5yrnnmshs
lock table sys.mon_mods$ in exclusive mode nowait

         386          386      2.16 g00cj285jmgsw
update sys.mon_mods$ set inserts = inserts + :ins, updates = updates + :upd, del
etes = deletes + :del, flags = (decode(bitand(flags, :flag), :flag, flags, flags
 + :flag)), drop_segments = drop_segments + :dropseg, timestamp = :time where ob
j# = :objn

         209          209      1.17 cm5vu20fhtnq1
select /*+ connect_by_filtering */ privilege#,level from sysauth$ connect by gra
ntee#=prior privilege# and privilege#>0 start with grantee#=:1 and privilege#>0

         205          205      1.15 a9gvfh5hx9u98
Module: Swingbench User Thread
BEGIN :1 := orderentry.processorders(:2 ,:3 ,:4 ); END;

         173            6      0.97 0v3dvmc22qnam
insert into sys.col_usage$ (obj#, intcol#, equality_preds, equijoin_preds, noneq
uijoin_preds, range_preds, like_preds, null_preds, timestamp) values ( :objn,
:coln, decode(bitand(:flag,1),0,0,1), decode(bitand(:flag,2),0,0,1), decod
e(bitand(:flag,4),0,0,1), decode(bitand(:flag,8),0,0,1), decode(bitand(:flag

         173          442      0.97 3c1kubcdjnppq
update sys.col_usage$ set equality_preds = equality_preds + decode(bitan
d(:flag,1),0,0,1), equijoin_preds = equijoin_preds + decode(bitand(:flag
,2),0,0,1), nonequijoin_preds = nonequijoin_preds + decode(bitand(:flag,4),0,0
,1), range_preds = range_preds + decode(bitand(:flag,8),0,0,1),

          -------------------------------------------------------------

SQL ordered by Sharable Memory               DB/Inst: ORCL/orcl  Snaps: 37-38
-> Only Statements with Sharable Memory greater than 1048576 are displayed

Sharable Mem (b)  Executions   % Total    SQL Id
---------------- ------------ -------- -------------
       2,106,812            1     0.95 2tr12b1b8uj71
Module: DBMS_SCHEDULER
MERGE /*+ dynamic_sampling(ST 4) dynamic_sampling_est_cdn(ST) */ INTO STATS_TARG
ET$ ST USING (SELECT STALENESS, OSIZE, OBJ#, TYPE#, CASE WHEN STALENESS > LOG(0.
01, NVL(LOC_STALE_PCT, :B1 )/100) THEN 128 ELSE 0 END + AFLAGS AFLAGS, STATUS, S
ID, SERIAL#, PART#, BO# FROM ( SELECT /*+ no_expand dynamic_sampling(4) dynamic_

          -------------------------------------------------------------

SQL ordered by Version Count                 DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Instance Activity Stats Section

This section provides us with a number of various statistics (such as, how many DBWR Checkpoints occurred, or how many consistent gets occurred during the snapshot). These are the statistics that the summary information is derived from. A list of the statistics maintained by the RDBMS kernel can be found in Appendix C of the Oracle Reference manual for the version being utilized.

Instance Activity Terminology

Session Logical Reads = All reads cached in memory.  Includes both consistent gets and also the db block gets.
Consistent Gets = These are the reads of a block that are in the cache.  They are NOT to be confused with consistent read (cr) version of a block in the buffer cache (usually the current version is read).
Db block gets = These are block gotten to be changed.  MUST be the CURRENT block and not a cr block.
Db block changes = These are the db block gets (above) that were actually changed.
Physical Reads = Blocks not read from the cache.  Either from disk, disk cache or O/S cache; there are also physical reads direct which bypass cache using Parallel Query (not in hit ratios).

Of particular interest are the following statistics.
- CPU USED BY THIS SESSION, PARSE TIME CPU or RECURSIVE CPU USAGE:  These numbers are useful to diagnose CPU saturation on the system (usually a query tuning issue). The formula to calculate the CPU usage breakdown is:
Service (CPU) Time = other CPU + parse time CPU
Other CPU = "CPU used by this session" - parse time CPU
Some releases do not correctly store this data and can show huge numbers. 

recursive cpu usage =  This component can be high if large amounts of PL/SQL are being processed. It is outside the scope of this document to go into detail with this, but you will need to identify your complete set of PL/SQL, including stored procedures, finding the ones with the highest CPU load and optimize these. If most work done in PL/SQL is procedural processing (rather than executing SQL), a high recursive cpu usage can actually indicate a potential tuning effort.

parse time cpu= Parsing SQL statements is a heavy operation, that should be avoided by reusing SQL statements as much as possible. In precompiler programs, unnecessary parting of implicit SQL statements can be avoided by increasing the cursor cache (MAXOPENCURSORS parameter) and by reusing cursors. In programs using Oracle Call Interface, you need to write the code, so that it re-executes (in stead of reparse) cursors with frequently executed SQL statements. The v$sql view contains PARSE_CALLS and EXECUTIONS columns, that can be used to identify SQL, that is parsed often or is only executed once per parse.

other cpu= The source of other cpu is primarily handling of buffers in the buffer cache. It can generally be assumed, that the CPU time spent by a SQL statement is approximately proportional to the number of buffer gets for that SQL statements, hence, you should identify and sort SQL statements by buffer gets in v$sql. In your report, look at the part ‘SQL ordered by Gets for DB’. Start tuning SQL statements from the top of this list. In Oracle, the v$sql view contain a column, CPU_TIME, which directly shows the cpu time associated with executing the SQL statement.

- DBWR BUFFERS SCANNED:  the number of buffers looked at when scanning the lru portion of the buffer cache for dirty buffers to make clean. Divide by "dbwr lru scans" to find the average number of buffers scanned. This count includes both dirty and clean buffers. The average buffers scanned may be different from the average scan depth due to write batches filling up before a scan is complete. Note that this includes scans for reasons other than make free buffer requests.
- DBWR CHECKPOINTS: the number of checkpoints messages that were sent to DBWR and not necessarily the total number of actual checkpoints that took place.  During a checkpoint there is a slight decrease in performance since data blocks are being written to disk and that causes I/O. If the number of checkpoints is reduced, the performance of normal database operations improve but recovery after instance failure is slower.
- DBWR TIMEOUTS: the number of timeouts when DBWR had been idle since the last timeout.  These are the times that DBWR looked for buffers to idle write.
- DIRTY BUFFERS INSPECTED: the number of times a foreground encountered a dirty buffer which had aged out through the lru queue, when foreground is looking for a buffer to reuse. This should be zero if DBWR is keeping up with foregrounds.
- FREE BUFFER INSPECTED: the number of buffers skipped over from the end of the LRU queue in order to find a free buffer.  The difference between this and "dirty buffers inspected" is the number of buffers that could not be used because they were busy or needed to be written after rapid aging out. They may have a user, a waiter, or being read/written.
- RECURSIVE CALLS:  Recursive calls occur because of cache misses and segment extension. In general if recursive calls is greater than 30 per process, the data dictionary cache should be optimized and segments should be rebuilt with storage clauses that have few large extents.  Segments include tables, indexes, rollback segment, and temporary segments.
NOTE: PL/SQL can generate extra recursive calls which may be unavoidable.
- REDO BUFFER ALLOCATION RETRIES: total number of retries necessary to allocate space in the redo buffer.  Retries are needed because either the redo writer has gotten behind, or because an event  (such as log switch) is occurring
- REDO LOG SPACE REQUESTS:  indicates how many times a user process waited for space in the redo log buffer.  Try increasing the init.ora parameter LOG_BUFFER so that zero Redo Log Space Requests are made.
- REDO WASTAGE: Number of bytes "wasted" because redo blocks needed to be written before they are completely full.   Early writing may be needed to commit transactions, to be able to write a database buffer, or to switch logs
- SUMMED DIRTY QUEUE LENGTH: the sum of the lruw queue length after every write request completes. (divide by write requests to get average queue length after write completion)
- TABLE FETCH BY ROWID: the number of rows that were accessed by a rowid.  This includes rows that were accessed using an index and rows that were accessed using the statement where rowid = 'xxxxxxxx.xxxx.xxxx'.
- TABLE FETCH BY CONTINUED ROW: indicates the number of rows that are chained to another block. In some cases (i.e. tables with long columns) this is unavoidable, but the ANALYZE table command should be used to further investigate the chaining, and where possible, should be eliminated by rebuilding the table.
- Table Scans (long tables) is the total number of full table scans performed on tables with more than 5 database blocks.  If the number of full table scans is high the application should be tuned to effectively use Oracle indexes. Indexes, if they exist, should be used on long tables if less than 10-20% (depending on parameter settings and CPU count) of the rows from the table are returned. If this is not the case, check the db_file_multiblock_read_count parameter setting. It may be too high.  You may also need to tweak optimizer_index_caching and optimizer_index_cost_adj.
- Table Scans (short tables) is the number of full table scans performed on tables with less than 5 database blocks.  It is optimal to perform full table scans on short tables rather than using indexes.

Instance Activity Stats                      DB/Inst: ORCL/orcl  Snaps: 37-38
-> Ordered by statistic name

Statistic                                     Total     per Second     per Trans
-------------------------------- ------------------ -------------- -------------
Batched IO (bound) vector count                   0            0.0           0.0
Batched IO (full) vector count                  208            0.6           0.0
Batched IO block miss count                   2,027            5.6           0.2
Batched IO buffer defrag count                  103            0.3           0.0
Batched IO double miss count                    916            2.5           0.1
Batched IO same unit count                        0            0.0           0.0
Batched IO single block count                   576            1.6           0.1
Batched IO vector block count                 1,659            4.6           0.2
Batched IO vector read count                    548            1.5           0.1
Block Cleanout Optim referenced               1,335            3.7           0.2
CCursor + sql area evicted                       17            0.1           0.0
CPU used by this session                      4,767           13.2           0.5
CPU used when call started                    3,613           10.0           0.4
CR blocks created                                48            0.1           0.0
Cached Commit SCN referenced                      0            0.0           0.0
Commit SCN cached                               148            0.4           0.0
DB time                                   1,454,326        4,021.4         161.7
DBWR checkpoint buffers written               3,176            8.8           0.4
DBWR checkpoints                                  0            0.0           0.0
DBWR transaction table writes                    28            0.1           0.0
DBWR undo block writes                          607            1.7           0.1
HSC Heap Segment Block Changes               24,764           68.5           2.8
Heap Segment Array Inserts                       79            0.2           0.0
Heap Segment Array Updates                       20            0.1           0.0
IMU CR rollbacks                                 21            0.1           0.0
IMU Flushes                                     582            1.6           0.1
IMU Redo allocation size                  3,215,316        8,890.8         357.5
IMU commits                                   6,834           18.9           0.8
IMU contention                                  448            1.2           0.1
IMU ktichg flush                                  3            0.0           0.0
IMU pool not allocated                        1,591            4.4           0.2
IMU undo allocation size                 19,704,704       54,486.0       2,191.1
IMU- failed to get a private str              1,591            4.4           0.2
LOB table id lookup cache misses                  0            0.0           0.0
Number of read IOs issued                         0            0.0           0.0
RowCR - row contention                            7            0.0           0.0
RowCR attempts                                2,846            7.9           0.3
RowCR hits                                    2,837            7.8           0.3
SMON posted for undo segment shr                 11            0.0           0.0
SQL*Net roundtrips to/from clien              6,298           17.4           0.7
TBS Extension: bytes extended                     0            0.0           0.0
TBS Extension: files extended                     0            0.0           0.0
TBS Extension: tasks created                      0            0.0           0.0
TBS Extension: tasks executed                     0            0.0           0.0
active txn count during cleanout                269            0.7           0.0
application wait time                             0            0.0           0.0
background checkpoints completed                  0            0.0           0.0
background checkpoints started                    0            0.0           0.0
background timeouts                           1,506            4.2           0.2
branch node splits                                1            0.0           0.0
buffer is not pinned count                  287,547          795.1          32.0
buffer is pinned count                      291,344          805.6          32.4
bytes received via SQL*Net from           1,278,058        3,534.0         142.1
bytes sent via SQL*Net to client            664,996        1,838.8          74.0
calls to get snapshot scn: kcmgs             91,677          253.5          10.2
calls to kcmgas                              10,858           30.0           1.2
calls to kcmgcs                              46,250          127.9           5.1
cell physical IO interconnect by        545,082,880    1,507,223.6      60,611.9
change write time                               116            0.3           0.0
cleanout - number of ktugct call              3,428            9.5           0.4
Instance Activity Stats                      DB/Inst: ORCL/orcl  Snaps: 37-38
-> Ordered by statistic name

Statistic                                     Total     per Second     per Trans
-------------------------------- ------------------ -------------- -------------
cleanouts and rollbacks - consis                 21            0.1           0.0
cleanouts only - consistent read                277            0.8           0.0
cluster key scan block gets                  18,417           50.9           2.1
cluster key scans                            16,666           46.1           1.9
commit batch/immediate performed                  6            0.0           0.0
commit batch/immediate requested                  6            0.0           0.0
commit cleanout failures: block                   6            0.0           0.0
commit cleanout failures: buffer                  5            0.0           0.0
commit cleanout failures: callba                  8            0.0           0.0
commit cleanout failures: cannot                126            0.4           0.0
commit cleanouts                             42,332          117.1           4.7
commit cleanouts successfully co             42,187          116.7           4.7
commit immediate performed                        6            0.0           0.0
commit immediate requested                        6            0.0           0.0
commit txn count during cleanout              3,963           11.0           0.4
concurrency wait time                         2,897            8.0           0.3
consistent changes                              255            0.7           0.0
consistent gets                             505,451        1,397.6          56.2
consistent gets - examination               301,067          832.5          33.5
consistent gets direct                            0            0.0           0.0
consistent gets from cache                  505,451        1,397.6          56.2
consistent gets from cache (fast            192,185          531.4          21.4
cursor authentications                          137            0.4           0.0
data blocks consistent reads - u                 56            0.2           0.0
db block changes                            146,506          405.1          16.3
db block gets                               225,769          624.3          25.1
db block gets direct                             38            0.1           0.0
db block gets from cache                    225,731          624.2          25.1
db block gets from cache (fastpa             76,841          212.5           8.5
deferred (CURRENT) block cleanou             17,990           49.7           2.0
dirty buffers inspected                       8,006           22.1           0.9
enqueue conversions                             311            0.9           0.0
enqueue releases                             44,413          122.8           4.9
enqueue requests                             44,424          122.8           4.9
enqueue timeouts                                  1            0.0           0.0
enqueue waits                                     3            0.0           0.0
execute count                                92,773          256.5          10.3
file io service time                            623            1.7           0.1
file io wait time                     6,744,677,484   18,649,892.0     749,991.9
free buffer inspected                        43,511          120.3           4.8
free buffer requested                        49,975          138.2           5.6
heap block compress                              25            0.1           0.0
hot buffers moved to head of LRU             20,716           57.3           2.3
immediate (CR) block cleanout ap                298            0.8           0.0
immediate (CURRENT) block cleano              2,318            6.4           0.3
index crx upgrade (positioned)                    0            0.0           0.0
index fast full scans (full)                      9            0.0           0.0
index fetch by key                          142,477          394.0          15.8
index scans kdiixs1                          24,421           67.5           2.7
leaf node 90-10 splits                           16            0.0           0.0
leaf node splits                                 85            0.2           0.0
lob reads                                        11            0.0           0.0
lob writes                                      114            0.3           0.0
lob writes unaligned                            114            0.3           0.0
logons cumulative                                90            0.3           0.0
max cf enq hold time                          1,890            5.2           0.2
messages received                             5,474           15.1           0.6
messages sent                                 5,474           15.1           0.6
min active SCN optimization appl              8,397           23.2           0.9
no work - consistent read gets              154,262          426.6          17.2
Instance Activity Stats                      DB/Inst: ORCL/orcl  Snaps: 37-38
-> Ordered by statistic name

Statistic                                     Total     per Second     per Trans
-------------------------------- ------------------ -------------- -------------
non-idle wait count                          75,058          207.5           8.4
non-idle wait time                          878,269        2,428.5          97.7
opened cursors cumulative                   100,941          279.1          11.2
parse count (describe)                            7            0.0           0.0
parse count (failures)                            5            0.0           0.0
parse count (hard)                              328            0.9           0.0
parse count (total)                          17,837           49.3           2.0
parse time cpu                                   82            0.2           0.0
parse time elapsed                            3,980           11.0           0.4
physical read IO requests                    38,018          105.1           4.2
physical read bytes                     387,776,512    1,072,251.4      43,119.8
physical read total IO requests              38,552          106.6           4.3
physical read total bytes               396,509,184    1,096,398.4      44,090.9
physical read total multi block                 285            0.8           0.0
physical reads                               47,336          130.9           5.3
physical reads cache                         47,336          130.9           5.3
physical reads cache prefetch                10,425           28.8           1.2
physical reads direct                             0            0.0           0.0
physical reads direct (lob)                       0            0.0           0.0
physical reads prefetch warmup                7,944           22.0           0.9
physical write IO requests                    9,495           26.3           1.1
physical write bytes                    120,586,240      333,436.3      13,408.9
physical write total IO requests             13,380           37.0           1.5
physical write total bytes              148,573,696      410,825.2      16,521.0
physical write total multi block                 69            0.2           0.0
physical writes                              14,720           40.7           1.6
physical writes direct                           38            0.1           0.0
physical writes direct (lob)                      0            0.0           0.0
physical writes direct temporary                  1            0.0           0.0
physical writes from cache                   14,682           40.6           1.6
physical writes non checkpoint               14,356           39.7           1.6
pinned buffers inspected                          2            0.0           0.0
pinned cursors current                            4            0.0           0.0
prefetch warmup blocks aged out               4,354           12.0           0.5
prefetched blocks aged out befor                167            0.5           0.0
process last non-idle time                   13,843           38.3           1.5
recursive calls                             179,879          497.4          20.0
recursive cpu usage                           1,854            5.1           0.2
redo blocks checksummed by FG (e             18,841           52.1           2.1
redo blocks written                          43,463          120.2           4.8
redo entries                                 39,393          108.9           4.4
redo ordering marks                             457            1.3           0.1
redo size                                20,574,124       56,890.1       2,287.8
redo size for direct writes                     208            0.6           0.0
redo subscn max counts                        2,054            5.7           0.2
redo synch time                             151,352          418.5          16.8
redo synch writes                             6,139           17.0           0.7
redo wastage                                933,440        2,581.1         103.8
redo write time                              25,792           71.3           2.9
redo writes                                   3,483            9.6           0.4
rollback changes - undo records                  11            0.0           0.0
rollbacks only - consistent read                 13            0.0           0.0
rows fetched via callback                    48,234          133.4           5.4
scheduler wait time                           5,964           16.5           0.7
session connect time                              0            0.0           0.0
session cursor cache hits                    97,379          269.3          10.8
session logical reads                       731,220        2,021.9          81.3
shared hash latch upgrades - no              23,596           65.3           2.6
sorts (memory)                                1,491            4.1           0.2
sorts (rows)                                 24,199           66.9           2.7
Instance Activity Stats                      DB/Inst: ORCL/orcl  Snaps: 37-38
-> Ordered by statistic name

Statistic                                     Total     per Second     per Trans
-------------------------------- ------------------ -------------- -------------
sql area evicted                                143            0.4           0.0
sql area purged                                   8            0.0           0.0
summed dirty queue length                    24,427           67.5           2.7
switch current to new buffer                     61            0.2           0.0
table fetch by rowid                        202,035          558.7          22.5
table fetch continued row                       206            0.6           0.0
table scan blocks gotten                     47,299          130.8           5.3
table scan rows gotten                    1,355,176        3,747.2         150.7
table scans (long tables)                         0            0.0           0.0
table scans (short tables)                   15,062           41.7           1.7
temp space allocated (bytes)              5,242,880       14,497.2         583.0
total cf enq hold time                        3,890           10.8           0.4
total number of cf enq holders                   14            0.0           0.0
total number of times SMON poste                 11            0.0           0.0
transaction rollbacks                             6            0.0           0.0
undo change vector size                   6,909,880       19,106.7         768.4
user I/O wait time                          687,066        1,899.8          76.4
user calls                                   12,544           34.7           1.4
user commits                                  8,993           24.9           1.0
workarea executions - optimal                   668            1.9           0.1
write clones created in foregrou                 17            0.1           0.0
          -------------------------------------------------------------

Instance Activity Stats - Absolute Values    DB/Inst: ORCL/orcl  Snaps: 37-38
-> Statistics with absolute values (should not be diffed)

Statistic                            Begin Value       End Value
-------------------------------- --------------- ---------------
session pga memory max               248,230,328     308,024,768
session cursor cache count                 4,536           7,127
session uga memory               1.975906811E+11 2.018948513E+11
opened cursors current                        39              58
logons current                                25              27
session uga memory max               371,408,336     625,059,064
session pga memory                   151,482,136     193,123,104
          -------------------------------------------------------------

Instance Activity Stats - Thread Activity     DB/Inst: ORCL/orcl  Snaps: 37-38
-> Statistics identified by '(derived)' come from sources other than SYSSTAT

Statistic                                     Total  per Hour
-------------------------------- ------------------ ---------
log switches (derived)                            0       .00
          -------------------------------------------------------------

I/O Stats Section
The IO Stats stats report provides information on tablespace IO performance. From this report you can determine if the tablespace or datafiles are suffering from sub-standard performance in terms of IO response from the disk sub-system.
IO Activity Input/Output (IO) statistics for the instance are listed in the following sections/formats:

- Tablespace I/O Stats for DB: Ordered by total IO per tablespace.
- File I/O Stats for DB: Ordered alphabetically by tablespace, filename.

If the statistic "Buffer Waits" for a tablespace is greater than 1000, you may want to consider tablespace reorganization in order to spread tables within it across another tablespaces.

Note that Oracle considers average read times of greater than 20 ms unacceptable.  If a datafile consistently has average read times of 20 ms or greater then:
- The queries against the contents of the owning tablespace should be examined and tuned so that less data is retrieved.
- If the tablespace contains indexes, another option is to compress the indexes so that they require less space and hence, less IO.
- The contents of that datafile should be redistributed across several disks/logical volumes to more easily accommodate the load.
- If the disk layout seems optimal, check the disk controller layout.  It may be that the datafiles need to be distributed across more disk sets.

If the tablespace IO report seems to indicate a tablespace has IO problems, we can then use the file IO stat report allows us to drill into the datafiles of the tablespace in question and determine what the problem might be.

IOStat by Function summary                    DB/Inst: ORCL/orcl  Snaps: 37-38
-> 'Data' columns suffixed with M,G,T,P are in multiples of 1024
    other columns suffixed with K,M,G,T,P are in multiples of 1000
-> ordered by (Data Read + Write) desc

                Reads:   Reqs   Data    Writes:  Reqs   Data    Waits:    Avg
Function Name   Data    per sec per sec Data    per sec per sec Count    Tm(ms)
--------------- ------- ------- ------- ------- ------- ------- ------- -------
Buffer Cache Re    370M   105.3 1.02309      0M     0.0      0M   37.5K   187.4
DBWR                 0M     0.0      0M    118M    27.0 .326285    2004    25.2
LGWR                 0M     0.0      0M     21M     9.8 .058067    3482    73.6
Others               8M     1.5 .022121      5M     1.0 .013825     880    29.0
Direct Writes        0M     0.0      0M      0M     0.0      0M       5     0.0
TOTAL:             378M   106.7 1.04521    144M    37.7 .398178   43.9K   167.8
          -------------------------------------------------------------

IOStat by Filetype summary                    DB/Inst: ORCL/orcl  Snaps: 37-38
-> 'Data' columns suffixed with M,G,T,P are in multiples of 1024
    other columns suffixed with K,M,G,T,P are in multiples of 1000
-> Small Read and Large Read are average service times, in milliseconds
-> Ordered by (Data Read + Write) desc

                Reads:   Reqs   Data    Writes:  Reqs   Data      Small   Large
Filetype Name   Data    per sec per sec Data    per sec per sec    Read    Read
--------------- ------- ------- ------- ------- ------- ------- ------- -------
Data File          369M   105.3 1.02033    119M    27.0 .329050   184.5   202.9
Log File             0M     0.0      0M     21M     9.8 .058067     N/A     N/A
Control File         8M     1.4 .022121      6M     1.0 .016590     2.3     N/A
Temp File            0M     0.0      0M      0M     0.0      0M    33.0     N/A
TOTAL:             377M   106.7 1.04245    146M    37.7 .403708   182.0   202.9
          -------------------------------------------------------------

IOStat by Function/Filetype summary           DB/Inst: ORCL/orcl  Snaps: 37-38
-> 'Data' columns suffixed with M,G,T,P are in multiples of 1024
    other columns suffixed with K,M,G,T,P are in multiples of 1000
-> Ordered by (Data Read + Write) desc for each function

 Reads:   Reqs   Data    Writes:  Reqs   Data    Waits:    Avg
 Data    per sec per sec Data    per sec per sec Count    Tm(ms)
 ------- ------- ------- ------- ------- ------- ------- -------
Buffer Cache Reads
    370M   105.3 1.02309      0M     0.0      0M   36.4K   183.9
 Buffer Cache Reads (Data File)
    370M   105.3 1.02309      0M     0.0      0M   36.4K   183.9
DBWR
      0M     0.0      0M    118M    27.0 .326285       0     N/A
 DBWR (Data File)
      0M     0.0      0M    118M    27.0 .326285       0     N/A
LGWR
      0M     0.0      0M     21M     9.8 .058067       0     N/A
 LGWR (Log File)
      0M     0.0      0M     21M     9.8 .058067       0     N/A
Others
      8M     1.5 .022121      5M     1.0 .013825     530     3.7
 Others (Control File)
      8M     1.4 .022121      5M     1.0 .013825     524     2.3
 Others (Data File)
      0M     0.0      0M      0M     0.0      0M       6   131.3
Direct Writes
      0M     0.0      0M      0M     0.0      0M       0     N/A
 Direct Writes (Data File)
      0M     0.0      0M      0M     0.0      0M       0     N/A
TOTAL:
    378M   106.7 1.04521    144M    37.7 .398178     37K   181.3
          -------------------------------------------------------------

Tablespace IO Stats                          DB/Inst: ORCL/orcl  Snaps: 37-38
-> ordered by IOs (Reads + Writes) desc

Tablespace
------------------------------
                 Av       Av     Av                       Av     Buffer  Av Buf
         Reads Reads/s  Rd(ms) Blks/Rd       Writes Writes/s      Waits  Wt(ms)
-------------- ------- ------- ------- ------------ -------- ---------- -------
SOE
        37,134     103   177.6     1.2        9,009       25         34   203.2 @jls
SYSTEM
           694       2   115.7     3.0           16        0         67    14.0
SYSAUX
            50       0   103.4     1.1          218        1          0     0.0
UNDOTBS1
             8       0   320.0     1.0           80        0          1     0.0
TEMP
             1       0    40.0     1.0            3        0          0     0.0
          -------------------------------------------------------------

File IO Stats                                DB/Inst: ORCL/orcl  Snaps: 37-38
-> ordered by Tablespace, File

Tablespace               Filename
------------------------ ----------------------------------------------------
                 Av       Av     Av                       Av     Buffer  Av Buf
         Reads Reads/s  Rd(ms) Blks/Rd       Writes Writes/s      Waits  Wt(ms)
-------------- ------- ------- ------- ------------ -------- ---------- -------
SOE                      /home/oracle/app/oracle/product/11.2.0/dbs/soe.dbf
        37,134     103   177.6     1.2        9,009       25         34   203.2
SYSAUX                   /home/oracle/app/oracle/oradata/orcl/sysaux01.dbf
            50       0   103.4     1.1          218        1          0     0.0
SYSTEM                   /home/oracle/app/oracle/oradata/orcl/system01.dbf
           694       2   115.7     3.0           16        0         67    14.0
TEMP                     /home/oracle/app/oracle/oradata/orcl/temp01.dbf
             1       0    40.0     1.0            3        0          0     N/A
UNDOTBS1                 /home/oracle/app/oracle/oradata/orcl/undotbs01.dbf
             8       0   320.0     1.0           80        0          1     0.0
          -------------------------------------------------------------

Buffer Pool Statistics Section

The buffer pool statistics report follows. It provides a summary of the buffer pool configuration and usage statistics.

The buffer statistics are comprised of two sections:

- Buffer Pool Statistics:  This section can have multiple entries if multiple buffer pools are allocated. A baseline of the database's buffer pool statistics should be available to compare with the current report buffer pool statistics.  A change in that pattern unaccounted for by a change in workload should be a cause for concern. Also check the Buffer Pool Advisory to identify if increasing that parameter (db_cache_size) would help to reduce Physical Reads.

Buffer Pool Statistics                       DB/Inst: ORCL/orcl  Snaps: 37-38
-> Standard block size Pools  D: default,  K: keep,  R: recycle
-> Default Pools for other block sizes: 2k, 4k, 8k, 16k, 32k

                                                            Free   Writ   Buffer
     Number of Pool       Buffer     Physical    Physical   Buff   Comp     Busy
P      Buffers Hit%         Gets        Reads      Writes   Wait   Wait    Waits
--- ---------- ---- ------------ ------------ ----------- ------ ------ --------
D       52,046   95      714,328       38,622      14,220      0      0      101
K       12,275   42       14,873        8,694         462      0      0        1
          -------------------------------------------------------------

Advisory Statistics Section

In this section, we receive several recommendations on changes that we can perform and how that will affect the overall performance of the DB.

Instance Recovery Stats

The instance recovery stats report provides information related to instance recovery. By analyzing this report, you can determine roughly how long your database would have required to perform crash recovery during the reporting period. Here is an example of this report:
          
Checkpoint Activity                           DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total Physical Writes:                       14,720

                                          Other    Autotune      Thread
       MTTR    Log Size    Log Ckpt    Settings        Ckpt        Ckpt
     Writes      Writes      Writes      Writes      Writes      Writes
----------- ----------- ----------- ----------- ----------- -----------
          0           0           0           0       3,176           0
          -------------------------------------------------------------

Instance Recovery Stats                       DB/Inst: ORCL/orcl  Snaps: 37-38
-> B: Begin Snapshot,  E: End Snapshot

                                                                            Estd
  Targt  Estd                                     Log Ckpt Log Ckpt    Opt   RAC
  MTTR   MTTR Recovery  Actual   Target   Log Sz   Timeout Interval    Log Avail
   (s)    (s) Estd IOs RedoBlks RedoBlks RedoBlks RedoBlks RedoBlks  Sz(M)  Time
- ----- ----- -------- -------- -------- -------- -------- -------- ------ -----
B     0    33     1667     2577    12920   165888    12920      N/A    N/A   N/A
E     0   140    14030    38327    56359   165888    56359      N/A    N/A   N/A
          -------------------------------------------------------------

MTTR Advisory                                     DB/Inst: ORCL/orcl  Snap: 38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Buffer Pool Advisory
The buffer pool advisory report answers the question, how big should you make your database buffer cache.
It provides an extrapolation of the benefit or detriment that would result if you added or removed memory from the database buffer cache. These estimates are based on the current size of the buffer cache and the number of logical and physical IO's encountered during the reporting point. This report can be very helpful in "rightsizing" your buffer cache.
Here is an example of the output of this report:

Buffer Pool Advisory                              DB/Inst: ORCL/orcl  Snap: 38
-> Only rows with estimated physical reads >0 are displayed
-> ordered by Block Size, Buffers For Estimate

                                    Est
                                   Phys      Estimated                  Est
    Size for   Size      Buffers   Read     Phys Reads     Est Phys %DBtime
P    Est (M) Factor  (thousands) Factor    (thousands)    Read Time for Rds
--- -------- ------ ------------ ------ -------------- ------------ -------
D         40     .1            5    2.1            205            1 2.0E+04
D         80     .2           10    1.6            158            1 1.5E+04
D        120     .3           15    1.4            134            1 1.2E+04
D        160     .4           20    1.2            123            1 1.1E+04
D        200     .5           25    1.2            117            1 1.0E+04
D        240     .6           29    1.1            112            1  9508.0
D        280     .7           34    1.1            108            1  9051.0
D        320     .8           39    1.1            105            1  8775.0
D        360     .8           44    1.0            103            1  8517.0
D        400     .9           49    1.0             99            1  8056.0
D        424    1.0           52    1.0             98            1  8000.0	@jls não compensa aumentar o tamanho pois o ganho será pouco, de 98 para 96 mesmo se dobrar o tamanho de 424 para 800
D        440    1.0           54    1.0             98            1  7973.0
D        480    1.1           59    1.0             98            1  7930.0
D        520    1.2           64    1.0             98            1  7892.0
D        560    1.3           69    1.0             97            1  7870.0
D        600    1.4           74    1.0             96            1  7744.0
D        640    1.5           79    1.0             96            1  7744.0
D        680    1.6           83    1.0             96            1  7744.0
D        720    1.7           88    1.0             96            1  7744.0
D        760    1.8           93    1.0             96            1  7744.0
D        800    1.9           98    1.0             96            1  7744.0
K          8     .1            1    1.1             14            1   562.0
K         16     .2            2    1.0             13            1   260.0
K         24     .2            3    1.0             12            1   236.0
K         32     .3            4    1.0             12            1   236.0
K         40     .4            5    1.0             12            1   236.0
K         48     .5            6    1.0             12            1   236.0
K         56     .6            7    1.0             12            1   236.0
K         64     .6            8    1.0             12            1   236.0
K         72     .7            9    1.0             12            1   236.0
K         80     .8           10    1.0             12            1   236.0
K         88     .9           11    1.0             12            1   236.0
K         96    1.0           12    1.0             12            1   236.0
K        100    1.0           12    1.0             12            1   236.0
K        104    1.0           13    1.0             12            1   236.0
K        112    1.1           14    1.0             12            1   236.0
K        120    1.2           15    1.0             12            1   236.0
K        128    1.3           16    1.0             12            1   236.0
K        136    1.4           17    1.0             12            1   236.0
K        144    1.4           18    1.0             12            1   236.0
K        152    1.5           19    1.0             12            1   236.0
K        160    1.6           20    1.0             12            1   236.0
          -------------------------------------------------------------

PGA Reports
The PGA reports provide some insight into the health of the PGA.
- The PGA Aggr Target Stats report provides information on the configuration of the PGA Aggregate Target parameter during the reporting period.
- The PGA Aggregate Target Histogram report provides information on the size of various operations (e.g. sorts). It will indicate if PGA sort operations occurred completely in memory, or if some of those operations were written out to disk.
- The PGA Memory Advisor, much like the buffer pool advisory report, provides some insight into how to properly size your PGA via the PGA_AGGREGATE_TARGET database parameter. 
          
PGA Aggr Summary                             DB/Inst: ORCL/orcl  Snaps: 37-38
-> PGA cache hit % - percentage of W/A (WorkArea) data processed only in-memory

PGA Cache Hit %   W/A MB Processed  Extra W/A MB Read/Written
--------------- ------------------ --------------------------
          100.0                 86                          0
          -------------------------------------------------------------

PGA Aggr Target Stats                         DB/Inst: ORCL/orcl  Snaps: 37-38
-> B: Begin Snap   E: End Snap (rows dentified with B or E contain data
   which is absolute i.e. not diffed over the interval)
-> Auto PGA Target - actual workarea memory target
-> W/A PGA Used    - amount of memory used for all Workareas (manual + auto)
-> %PGA W/A Mem    - percentage of PGA memory allocated to workareas
-> %Auto W/A Mem   - percentage of workarea memory controlled by Auto Mem Mgmt
-> %Man W/A Mem    - percentage of workarea memory under manual control

                                                %PGA  %Auto   %Man
    PGA Aggr   Auto PGA   PGA Mem    W/A PGA     W/A    W/A    W/A Global Mem
   Target(M)  Target(M)  Alloc(M)    Used(M)     Mem    Mem    Mem   Bound(K)
- ---------- ---------- ---------- ---------- ------ ------ ------ ----------
B        256        206       60.6        0.0     .0     .0     .0     54,886
E        256        200      105.0        0.0     .0     .0     .0     54,886
          -------------------------------------------------------------

PGA Aggr Target Histogram                     DB/Inst: ORCL/orcl  Snaps: 37-38
-> Optimal Executions are purely in-memory operations

  Low     High
Optimal Optimal    Total Execs  Optimal Execs 1-Pass Execs M-Pass Execs
------- ------- -------------- -------------- ------------ ------------
     2K      4K            579            579            0            0
    64K    128K              4              4            0            0
   128K    256K              1              1            0            0
   256K    512K              4              4            0            0
   512K   1024K             68             68            0            0
     1M      2M             14             14            0            0
     2M      4M              2              2            0            0
     4M      8M              2              2            0            0
          -------------------------------------------------------------

PGA Memory Advisory                               DB/Inst: ORCL/orcl  Snap: 38
-> When using Auto Memory Mgmt, minimally choose a pga_aggregate_target value
   where Estd PGA Overalloc Count is 0

                                       Estd Extra    Estd P Estd PGA
PGA Target    Size           W/A MB   W/A MB Read/    Cache Overallo    Estd
  Est (MB)   Factr        Processed Written to Disk   Hit %    Count    Time
---------- ------- ---------------- ---------------- ------ -------- -------
        34     0.1            999.6             61.9   94.0       16 1.3E+07
        67     0.3            999.6             21.8   98.0        7 1.3E+07
       134     0.5            999.6              3.3  100.0        3 1.2E+07
       201     0.8            999.6              0.0  100.0        0 1.2E+07  @jls
       268     1.0            999.6              0.0  100.0        0 1.2E+07
       322     1.2            999.6              0.0  100.0        0 1.2E+07
       375     1.4            999.6              0.0  100.0        0 1.2E+07
       429     1.6            999.6              0.0  100.0        0 1.2E+07
       482     1.8            999.6              0.0  100.0        0 1.2E+07
       536     2.0            999.6              0.0  100.0        0 1.2E+07
       804     3.0            999.6              0.0  100.0        0 1.2E+07
     1,072     4.0            999.6              0.0  100.0        0 1.2E+07
     1,608     6.0            999.6              0.0  100.0        0 1.2E+07
     2,144     8.0            999.6              0.0  100.0        0 1.2E+07
          -------------------------------------------------------------

Shared Pool Advisory

Use this section to evaluate your shared pool size parameter.
The shared pool advisory report provides assistance in right sizing the Oracle shared pool.
Much like the PGA Memory Advisor or the Buffer Pool advisory report, it provides some insight into what would happen should you add or remove memory from the shared pool. This can help you reclaim much needed memory if you have over allocated the shared pool, and can significantly improve performance if you have not allocated enough memory to the shared pool.

Other Advisories here
- SGA Target Advisory =  Helps for SGA_TARGET settings
- Streams Pool Advisory = Only if streams are used, if you are getting spills, indicates pool is too small
- Java Pool Advisory = Only if you are using internal Java, similar to the PL/SQL area in the library caches

Shared Pool Advisory                             DB/Inst: ORCL/orcl  Snap: 38
-> SP: Shared Pool     Est LC: Estimated Library Cache   Factr: Factor
-> Note there is often a 1:Many correlation between a single logical object
   in the Library Cache, and the physical number of memory objects associated
   with it.  Therefore comparing the number of Lib Cache objects (e.g. in
   v$librarycache), with the number of Lib Cache Memory Objects is invalid.

                                       Est LC Est LC  Est LC Est LC
  Shared    SP   Est LC                  Time   Time    Load   Load       Est LC
    Pool  Size     Size       Est LC    Saved  Saved    Time   Time      Mem Obj
 Size(M) Factr      (M)      Mem Obj      (s)  Factr     (s)  Factr     Hits (K)
-------- ----- -------- ------------ -------- ------ ------- ------ ------------
     164    .8       11          787    8,398    1.0     535    1.1           63
     188    .9       35        2,062    8,414    1.0     519    1.0          141
     212   1.0       59        2,710    8,438    1.0     495    1.0          142
     236   1.1       83        3,493    8,446    1.0     487    1.0          143
     260   1.2      107        4,521    8,450    1.0     483    1.0          143
     284   1.3      131        5,633    8,454    1.0     479    1.0          143
     308   1.5      152        6,665    8,455    1.0     478    1.0          143
     332   1.6      162        7,133    8,455    1.0     478    1.0          144
     356   1.7      162        7,133    8,455    1.0     478    1.0          144
     380   1.8      162        7,133    8,455    1.0     478    1.0          144
     404   1.9      162        7,133    8,455    1.0     478    1.0          144
     428   2.0      162        7,133    8,455    1.0     478    1.0          144
          -------------------------------------------------------------

SGA target advisory
The SGA target advisory report is somewhat of a summation of all the advisory reports previously presented in the AWR report. It helps you determine the impact of changing the settings of the SGA target size in terms of overall database performance. The report uses a value called DB Time as a measure of the increase or decrease in performance relative to the memory change made. Also the report will summarize an estimate of physical reads associated with the listed setting for the SGA. Here is an example of the SGA target advisory report:

SGA Target Advisory                               DB/Inst: ORCL/orcl  Snap: 38

SGA Target   SGA Size       Est DB     Est Physical
  Size (M)     Factor     Time (s)            Reads
---------- ---------- ------------ ----------------
       378        0.5       17,280          151,748
       567        0.8       11,821          103,228
       756        1.0       11,069           96,538
       945        1.3       10,930           95,727 @jls
     1,134        1.5       10,924           95,727
     1,323        1.8       10,924           95,727
     1,512        2.0       10,823           98,882
          -------------------------------------------------------------

Streams Pool Advisory                             DB/Inst: ORCL/orcl  Snap: 38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Java Pool Advisory                                DB/Inst: ORCL/orcl  Snap: 38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Buffer Wait Statistics

The buffer wait statistics report helps you drill down on specific buffer wait events, and where the waits are occurring. In the following report we find that the 13 buffer busy waits we saw in the buffer pool statistics report earlier are attributed to data block waits. We might then want to pursue tuning remedies to these waits if the waits are significant enough. Here is an example
of the buffer wait statistics report:

Buffer Wait Statistics                        DB/Inst: ORCL/orcl  Snaps: 37-38
-> ordered by wait time desc, waits desc

Class                    Waits Total Wait Time (s)  Avg Time (ms)
------------------ ----------- ------------------- --------------
data block                  98                   7             75
1st level bmb                2                   0            205
2nd level bmb                1                   0            100
undo header                  1                   0              0
          -------------------------------------------------------------

Enqueue Statistics

An enqueue is simply a locking mechanism. This section is very useful and must be used when the wait event "enqueue" is listed in the "Top 5 timed events".
The Enqueue activity report provides information on enqueues (higher level Oracle locking) that occur.
As with other reports, if you see high levels of wait times in these reports, you might dig further into the nature of the enqueue and determine the cause of the delays. 

Enqueue Activity                             DB/Inst: ORCL/orcl  Snaps: 37-38
-> only enqueues with waits are shown
-> Enqueue stats gathered prior to 10g should not be compared with 10g data
-> ordered by Wait Time desc, Waits desc

Enqueue Type (Request Reason)
------------------------------------------------------------------------------
    Requests    Succ Gets Failed Gets       Waits  Wt Time (s) Av Wt Time(ms)
------------ ------------ ----------- ----------- ------------ --------------
TX-Transaction (index contention)
          21           21           0           2            1         275.00
JS-Job Scheduler (queue lock)
       1,311        1,311           0           1            0            .00
          -------------------------------------------------------------

The action to take depends on the lock type that is causing the most problems.  The most common lock waits are generally for:

- TX (Transaction Lock): Generally due to application concurrency mechanisms, or table setup issues. The TX lock is acquired when a transaction initiates its first change and is held until the transaction does a COMMIT or ROLLBACK. It is used mainly as a queuing mechanism so that other resources can wait for a transaction to complete.

- TM (DML enqueue): Generally due to application issues, particularly if foreign key constraints have not been indexed. This lock/enqueue is acquired when performing an insert, update, or delete on a parent or child table.

- ST (Space management enqueue): Usually caused by too much space management occurring. For example: create table as select on large tables on busy instances, small extent sizes, lots of sorting, etc. These enqueues are caused if a lot of space management activity is occurring on the database (such as small extent size, several sortings occurring on the disk).

V$SESSION_WAIT and V$LOCK give more data about enqueues
- The P1, P2 and P3 values tell what the enqueuemay have been waiting on
- For BF we get node#, parallelizer#, and bloom#

column parameter1 format a15
column parameter2 format a15
column parameter3 format a15
column lock format a8
Select substr(name,1,7) as "lock",parameter1,parameter2,parameter3
from v$event_name
where name like 'enq%';

Undo Statistics Section
The undo segment summary report provides basic information on the performance of undo tablespaces.

Undo information is provided in the following sections:
- Undo Segment Summary
- Undo Segment Stats 

The description of the view V$UNDOSTAT in the Oracle Database Reference guide provides some insight as to the columns definitions.  Should the client encounter SMU problems, monitoring this view every few minutes would provide more useful information. 

Undo Segment Summary                         DB/Inst: ORCL/orcl  Snaps: 37-38
-> Min/Max TR (mins) - Min and Max Tuned Retention (minutes)
-> STO - Snapshot Too Old count,  OOS - Out of Space count
-> Undo segment block stats:
-> uS - unexpired Stolen,   uR - unexpired Released,   uU - unexpired reUsed
-> eS - expired   Stolen,   eR - expired   Released,   eU - expired   reUsed

Undo   Num Undo       Number of  Max Qry   Max Tx Min/Max   STO/     uS/uR/uU/
 TS# Blocks (K)    Transactions  Len (s) Concurcy TR (mins) OOS      eS/eR/eU
---- ---------- --------------- -------- -------- --------- ----- --------------
   2         .7           7,671      920       33 29.4/29.4 0/0   0/0/0/0/0/0
          -------------------------------------------------------------

Undo Segment Stats                            DB/Inst: ORCL/orcl  Snaps: 37-38
-> Most recent 35 Undostat rows, ordered by Time desc

                Num Undo    Number of Max Qry  Max Tx Tun Ret STO/    uS/uR/uU/
End Time          Blocks Transactions Len (s)   Concy  (mins) OOS     eS/eR/eU
------------ ----------- ------------ ------- ------- ------- ----- ------------
12-Feb 12:19         733        7,671     920      33      29 0/0   0/0/0/0/0/0
          -------------------------------------------------------------

This section provides a more detailed look at the statistics in the previous section by listing the information as it appears in each snapshot.

Use of UNDO_RETENTION can potentially increase the size of the undo segment for a given period of time, so the retention period should not be arbitrarily set too high. The UNDO tablespace still must be sized appropriately. The following calculation can be used to determine how much space a given undo segment will consume given a set value of UNDO_RETENTION.
Undo Segment Space Required = (undo_retention_time * undo_blocks_per_seconds)

As an example, an UNDO_RETENTION of 5 minutes (default) with 50 undo blocks/second (8k blocksize) will generate:

Undo Segment Space Required = (300 seconds * 50 blocks/ seconds * 8K/block) = 120 M

The retention information (transaction commit time) is stored in every transaction table block and each extent map block. When the retention period has expired, SMON will be signaled to perform undo reclaims, done by scanning each transaction table for undo timestamps and deleting the information from the undo segment extent map. Only during extreme space constraint issues will retention period not be obeyed. 

Latch Statistics Section

The latch activity report provides information on Oracle's low level locking mechanism called a latch. From this report you can determine if Oracle is suffering from latching problems, and if so, which latches are causing the greatest amount of contention on the system.

Latch information is provided in the following three sections:
. Latch Activity
. Latch Sleep breakdown
. Latch Miss Sources

This information should be checked whenever the "latch free" wait event or other latch wait events experience long waits. This section is particularly useful for determining latch contention on an instance.  Latch contention generally indicates resource contention and supports indications of it in other sections. Latch contention is indicated by a Pct Miss of greater than 1.0% or a relatively high value in Avg Sleeps/Miss. While each latch can indicate contention on some resource, the more common latches to watch are:

cache buffer chain= The cache buffer chain latch protects the hash chain of cache buffers, and is used for each access to cache buffers. Contention for this latch can often only be reduced by reducing the amount of access to cache buffers. Using the X$BH fixed table can identify if some hash chains have many buffers associated with them. Often, a single hot block, such as an index root block, can cause contention for this latch. Contention on this latch confirms a hot block issue.
shared pool= The shared pool latch is heavily used during parsing, in particular during hard parse. If your application is written so that it generally uses literals in stead of bind variables, you will have high contention on this latch. Contention on this latch in conjunction with reloads in the SQL Area of the library cache section indicates that the shared pool is too small. You can set the cursor_sharing parameter in init.ora to the value ‘force’ to reduce the hard parsing and reduce some of the contention for the shared pool latch. Applications that are coded to only parse once per cursor and execute multiple times will almost completely avoid contention for the shared pool latch.

    Literal SQL is being used. See Note 62143.1 'Understanding and Tuning the Shared Pool for an excellent discussion of this topic.
    The parameter session_cached_cursors might need to be set.  See enhancement bug 1589185 for details.

library cache= The library cache latch is heavily used during both hard and soft parsing. If you have high contention for this latch, your application should be modified to avoid parsing if at all possible. Setting the cursor_sharing parameter in init.ora to the value ‘force’ provides some reduction in the library cache latch needs for hard parses, and setting the session_cached_cursors sufficiently high provides some reduction in the library cache latch needs for repeated soft parsing within a single session. There is minor contention for this latch involved in executing SQL statements, which can be reduced further by setting cursor_space_for_time=true, if the application is properly written to parse statements once and execute multiple times.
row cache= The row cache latch protects the data dictionary information, such as information about tables and columns. During hard parsing, this latch is used extensively. The cursor_sharing parameter can be used to completely avoid the row cache latch lookup during parsing.
cache buffer lru chain= The buffer cache has a set of chains of LRU block, each protected by one of these latches. Contention for this latch can often be reduced by increasing the db_block_lru_latches parameter or by reducing the amount of access to cachebuffers.

Latch Activity                               DB/Inst: ORCL/orcl  Snaps: 37-38
-> "Get Requests", "Pct Get Miss" and "Avg Slps/Miss" are statistics for
   willing-to-wait latch get requests
-> "NoWait Requests", "Pct NoWait Miss" are for no-wait latch get requests
-> "Pct Misses" for both should be very close to 0.0

                                           Pct    Avg   Wait                 Pct
                                    Get    Get   Slps   Time       NoWait NoWait
Latch Name                     Requests   Miss  /Miss    (s)     Requests   Miss
------------------------ -------------- ------ ------ ------ ------------ ------
AQ deq hash table latch               1    0.0             0            0    N/A
ASM db client latch                 388    0.0             0            0    N/A
ASM map operation hash t              1    0.0             0            0    N/A
ASM network state latch               6    0.0             0            0    N/A
AWR Alerted Metric Eleme          2,726    0.0             0            0    N/A
Change Notification Hash            117    0.0             0            0    N/A
Consistent RBA                    3,481    0.0             0            0    N/A
DML lock allocation              59,925    0.0    0.0      0            0    N/A
Event Group Locks                    90    0.0             0            0    N/A
FOB s.o list latch                  496    1.4    0.1      0            0    N/A
File State Object Pool P              1    0.0             0            0    N/A
IPC stats buffer allocat              1    0.0             0            0    N/A
In memory undo latch             61,921    0.0    1.0      0        9,081    0.0
JS Sh mem access                      3   33.3    1.0      0            0    N/A
JS broadcast autostart l              1    0.0             0            0    N/A
JS mem alloc latch                    4    0.0             0            0    N/A
JS queue access latch                 5    0.0             0            0    N/A
JS queue state obj latch          2,622    0.0             0            0    N/A
JS slv state obj latch              326    0.6    0.0      0            0    N/A
KFC FX Hash Latch                     1    0.0             0            0    N/A
KFC Hash Latch                        1    0.0             0            0    N/A
KFCL LE Freelist                      1    0.0             0            0    N/A
KGNFS-NFS:SHM structure               1    0.0             0            0    N/A
KGNFS-NFS:SVR LIST                    1    0.0             0            0    N/A
KJC message pool free li              1    0.0             0            0    N/A
KJCT flow control latch               1    0.0             0            0    N/A
KMG MMAN ready and start            122    0.0             0            0    N/A
KTF sga latch                         2    0.0             0          120    0.0
Locator state objects po              1    0.0             0            0    N/A
Lsod array latch                      1    0.0             0            0    N/A
MQL Tracking Latch                    0    N/A             0            9    0.0
Memory Management Latch               1    0.0             0          122    0.0
Memory Queue                          1    0.0             0            0    N/A
Memory Queue Message Sub              1    0.0             0            0    N/A
Memory Queue Message Sub              1    0.0             0            0    N/A
Memory Queue Message Sub              1    0.0             0            0    N/A
Memory Queue Message Sub              1    0.0             0            0    N/A
Memory Queue Subscriber               1    0.0             0            0    N/A
MinActiveScn Latch                    2    0.0             0            0    N/A
Mutex                                 1    0.0             0            0    N/A
Mutex Stats                           1    0.0             0            0    N/A
OS process                          484    0.0             0            0    N/A
OS process allocation               334    0.9    0.0      0            0    N/A
OS process: request allo            176    1.1    0.0      0            0    N/A
PL/SQL warning settings           6,155    0.2    0.0      0            0    N/A
PX hash array latch                   1    0.0             0            0    N/A
QMT                                   1    0.0             0            0    N/A
Real-time plan statistic             74    0.0             0            0    N/A
SGA IO buffer pool latch            254    0.0             0          254    0.0
SGA blob parent                       1    0.0             0            0    N/A
SGA bucket locks                      1    0.0             0            0    N/A
SGA heap locks                        1    0.0             0            0    N/A
SGA pool locks                        1    0.0             0            0    N/A
SQL memory manager latch             13    0.0             0          118    0.0
SQL memory manager worka          8,670    0.0             0            0    N/A
Shared B-Tree                        14    0.0             0            0    N/A
Streams Generic                       1    0.0             0            0    N/A
Testing                               1    0.0             0            0    N/A
Token Manager                         1    0.0             0            0    N/A
WCR: sync                             1    0.0             0            0    N/A

Latch Activity                               DB/Inst: ORCL/orcl  Snaps: 37-38
-> "Get Requests", "Pct Get Miss" and "Avg Slps/Miss" are statistics for
   willing-to-wait latch get requests
-> "NoWait Requests", "Pct NoWait Miss" are for no-wait latch get requests
-> "Pct Misses" for both should be very close to 0.0

                                           Pct    Avg   Wait                 Pct
                                    Get    Get   Slps   Time       NoWait NoWait
Latch Name                     Requests   Miss  /Miss    (s)     Requests   Miss
------------------------ -------------- ------ ------ ------ ------------ ------
Write State Object Pool               1    0.0             0            0    N/A
X$KSFQP                               1    0.0             0            0    N/A
XDB NFS Security Latch                1    0.0             0            0    N/A
XDB unused session pool               1    0.0             0            0    N/A
XDB used session pool                 1    0.0             0            0    N/A
active checkpoint queue           1,895    0.0             0            0    N/A
active service list               1,252    0.3    0.5      0          728    0.0
begin backup scn array                4    0.0             0            0    N/A
buffer pool                           1    0.0             0            0    N/A
business card                         1    0.0             0            0    N/A
cache buffer handles              2,433    0.0             0            0    N/A
cache buffers chains          1,745,217    0.0    0.0      0       75,183    0.0
cache buffers lru chain          18,402    0.0    0.2      0       78,619    0.1
cache table scan latch              106    0.0             0          106    0.0
call allocation                   1,047    0.4    0.3      0            0    N/A
cas latch                             1    0.0             0            0    N/A
change notification clie              1    0.0             0            0    N/A
channel handle pool latc            181    0.0             0            0    N/A
channel operations paren          2,971    0.0    0.0      0            0    N/A
checkpoint queue latch           42,131    0.0             0       24,358    0.0
client/application info         250,902    0.1    0.0      0            0    N/A
compile environment latc             90    0.0             0            0    N/A
corrupted undo seg latch             46    0.0             0            0    N/A
cp cmon/server latch                  1    0.0             0            0    N/A
cp pool latch                         1    0.0             0            0    N/A
cp server hash latch                  1    0.0             0            0    N/A
cp sga latch                          6    0.0             0            0    N/A
cvmap freelist lock                   1    0.0             0            0    N/A
database property servic              8    0.0             0            0    N/A
deferred cleanup latch                6    0.0             0            0    N/A
dml lock allocation                  10    0.0             0            0    N/A
done queue latch                      1    0.0             0            0    N/A
dummy allocation                    179    0.0             0            0    N/A
enqueue hash chains              89,226    0.1    0.2      3            0    N/A
enqueues                          8,892    0.0    0.0      0            0    N/A
fifth spare latch                     1    0.0             0            0    N/A
file cache latch                    150    0.0             0            0    N/A
flashback copy                        1    0.0             0            0    N/A
gc element                            1    0.0             0            0    N/A
gcs commit scn state                  1    0.0             0            0    N/A
gcs partitioned table ha              1    0.0             0            0    N/A
gcs pcm hashed value buc              1    0.0             0            0    N/A
gcs resource freelist                 1    0.0             0            0    N/A
gcs resource hash                     1    0.0             0            0    N/A
gcs resource scan list                1    0.0             0            0    N/A
gcs shadows freelist                  1    0.0             0            0    N/A
ges domain table                      1    0.0             0            0    N/A
ges enqueue table freeli              1    0.0             0            0    N/A
ges group table                       1    0.0             0            0    N/A
ges process hash list                 1    0.0             0            0    N/A
ges process parent latch              1    0.0             0            0    N/A
ges resource hash list                1    0.0             0            0    N/A
ges resource scan list                1    0.0             0            0    N/A
ges resource table freel              1    0.0             0            0    N/A
ges value block free lis              1    0.0             0            0    N/A
global KZLD latch for me             80    0.0             0            0    N/A
global tx hash mapping                1    0.0             0            0    N/A
granule operation                     1    0.0             0            0    N/A
hash table column usage             359    0.0             0      247,004    0.0
hash table modification              56    0.0             0            0    N/A

Latch Activity                               DB/Inst: ORCL/orcl  Snaps: 37-38
-> "Get Requests", "Pct Get Miss" and "Avg Slps/Miss" are statistics for
   willing-to-wait latch get requests
-> "NoWait Requests", "Pct NoWait Miss" are for no-wait latch get requests
-> "Pct Misses" for both should be very close to 0.0

                                           Pct    Avg   Wait                 Pct
                                    Get    Get   Slps   Time       NoWait NoWait
Latch Name                     Requests   Miss  /Miss    (s)     Requests   Miss
------------------------ -------------- ------ ------ ------ ------------ ------
heartbeat check                       1    0.0             0            0    N/A
internal temp table obje              9    0.0             0            0    N/A
intra txn parallel recov              1    0.0             0            0    N/A
io pool granule metadata              1    0.0             0            0    N/A
job workq parent latch                4    0.0             0            3   33.3
job_queue_processes free              8    0.0             0            0    N/A
job_queue_processes para             78    0.0             0            0    N/A
k2q lock allocation                   1    0.0             0            0    N/A
kdlx hb parent latch                  1    0.0             0            0    N/A
kgb parent                            1    0.0             0            0    N/A
kks stats                           729    0.0             0            0    N/A
kokc descriptor allocati             13    0.0             0            0    N/A
ksfv messages                         1    0.0             0            0    N/A
kss move lock                         9    0.0             0            0    N/A
ksuosstats global area               28    0.0             0            0    N/A
ksv allocation latch                 22    0.0             0            0    N/A
ksv class latch                      17    0.0             0            0    N/A
ksv msg queue latch                   1    0.0             0            0    N/A
ksz_so allocation latch             176    0.6    0.0      0            0    N/A
ktm global data                      24    0.0             0            0    N/A
kwqbsn:qsga                          13    0.0             0            0    N/A
lgwr LWN SCN                      3,511    0.0             0            0    N/A
list of block allocation            262    0.0             0            0    N/A
loader state object free              4    0.0             0            0    N/A
lob segment dispenser la              1    0.0             0            0    N/A
lob segment hash table l              1    0.0             0            0    N/A
lob segment query latch               1    0.0             0            0    N/A
lock DBA buffer during m              1    0.0             0            0    N/A
logical standby cache                 1    0.0             0            0    N/A
logminer context allocat              1    0.0             0            0    N/A
logminer work area                    1    0.0             0            0    N/A
longop free list parent               1    0.0             0            0    N/A
mapped buffers lru chain              1    0.0             0            0    N/A
message pool operations             235    0.0             0            0    N/A
messages                         17,721    0.0    0.0      0            0    N/A
mostly latch-free SCN             3,512    0.0             0            0    N/A
msg queue latch                       1    0.0             0            0    N/A
multiblock read objects           2,138    0.0             0            0    N/A
name-service namespace b              1    0.0             0            0    N/A
ncodef allocation latch               6    0.0             0            0    N/A
object queue header heap          7,727    0.0             0          121    0.0
object queue header oper        138,877    0.0    0.1      0            0    N/A
object stats modificatio            551    0.0             0            0    N/A
parallel query alloc buf             45    0.0             0            0    N/A
parallel query stats                  1    0.0             0            0    N/A
parameter list                      761    0.0             0            0    N/A
parameter table manageme            178    0.0             0            0    N/A
peshm                                 1    0.0             0            0    N/A
pesom_free_list                       1    0.0             0            0    N/A
pesom_hash_node                       1    0.0             0            0    N/A
post/wait queue                  16,102    0.1    0.0      0       16,901    0.1
process allocation                  185    1.6    0.3      0           88    1.1
process group creation              176    2.8    0.0      0            0    N/A
process queue                         1    0.0             0            0    N/A
process queue reference               1    0.0             0            0    N/A
qmn task queue latch                 56    0.0             0            0    N/A
query server freelists                1    0.0             0            0    N/A
queued dump request                   1    0.0             0            0    N/A
queuing load statistics               1    0.0             0            0    N/A
recovery domain hash lis              1    0.0             0            0    N/A

Latch Activity                               DB/Inst: ORCL/orcl  Snaps: 37-38
-> "Get Requests", "Pct Get Miss" and "Avg Slps/Miss" are statistics for
   willing-to-wait latch get requests
-> "NoWait Requests", "Pct NoWait Miss" are for no-wait latch get requests
-> "Pct Misses" for both should be very close to 0.0

                                           Pct    Avg   Wait                 Pct
                                    Get    Get   Slps   Time       NoWait NoWait
Latch Name                     Requests   Miss  /Miss    (s)     Requests   Miss
------------------------ -------------- ------ ------ ------ ------------ ------
redo allocation                  25,541    0.1    0.1      0       39,323    0.1
redo copy                             1    0.0             0       39,346    0.3
redo writing                     12,652    0.0             0            0    N/A
resmgr group change latc         75,546    0.0    0.0      0            0    N/A
resmgr:active threads               342    0.0             0           60    0.0
resmgr:actses change gro            261    0.0             0            0    N/A
resmgr:actses change sta             88    0.0             0            0    N/A
resmgr:free threads list            184    0.5    0.0      0            0    N/A
resmgr:plan CPU method                1    0.0             0            0    N/A
resmgr:resource group CP              1    0.0             0            0    N/A
resmgr:schema config                 76    0.0             0            6    0.0
resmgr:session queuing                1    0.0             0            0    N/A
rm cas latch                          1    0.0             0            0    N/A
row cache objects               326,108    0.0    0.1      0          386    0.0
second spare latch                    1    0.0             0            0    N/A
sequence cache                    9,219    0.0             0            0    N/A
session allocation               27,806    0.0    0.0      0        9,271    0.1
session idle bit                 34,266    0.1    0.0      0            0    N/A
session queue latch                   1    0.0             0            0    N/A
session state list latch            510    0.4    0.0      0            0    N/A
session switching                   442    0.2    0.0      0            0    N/A
session timer                       138    0.0             0            0    N/A
shared pool                      49,560    0.2    0.1      2            0    N/A
shared pool sim alloc                12    0.0             0            0    N/A
shared pool simulator             2,437    0.0             0            0    N/A
sim partition latch                   1    0.0             0            0    N/A
simulator hash latch             59,731    0.0             0            0    N/A
simulator lru latch               1,459    0.0             0       54,264    0.0
sort extent pool                     46    0.0             0            0    N/A
space background task la            268    0.0             0          244    0.0
state object free list                2    0.0             0            0    N/A
statistics aggregation              560    0.0             0            0    N/A
tablespace key chain                  1    0.0             0            0    N/A
temp lob duration state               3    0.0             0            0    N/A
temporary table state ob              3    0.0             0            0    N/A
test excl. parent l0                  1    0.0             0            0    N/A
test excl. parent2 l0                 1    0.0             0            0    N/A
third spare latch                     1    0.0             0            0    N/A
threshold alerts latch               19    0.0             0            0    N/A
trace latch                          24    0.0             0            0    N/A
transaction allocation              411    0.0             0            0    N/A
undo global data                 50,436    0.0    0.0      0            0    N/A
virtual circuit buffers               1    0.0             0            0    N/A
virtual circuit holder                1    0.0             0            0    N/A
virtual circuit queues                1    0.0             0            0    N/A
          -------------------------------------------------------------

Latch Sleep Breakdown                        DB/Inst: ORCL/orcl  Snaps: 37-38
-> ordered by misses desc

                                       Get                                 Spin
Latch Name                        Requests       Misses      Sleeps        Gets
-------------------------- --------------- ------------ ----------- -----------
client/application info            250,902          325           6         319
cache buffers chains             1,745,217          320           1         319
shared pool                         49,560          105          11          96
enqueue hash chains                 89,226          104          18          86
row cache objects                  326,108           86           5          81
object queue header operat         138,877           16           1          15
redo allocation                     25,541           15           1          14
FOB s.o list latch                     496            7           1           6
cache buffers lru chain             18,402            6           1           5
active service list                  1,252            4           2           2
call allocation                      1,047            4           1           3
process allocation                     185            3           1           2
In memory undo latch                61,921            2           2           0
JS Sh mem access                         3            1           1           0
          -------------------------------------------------------------

Latch Miss Sources                           DB/Inst: ORCL/orcl  Snaps: 37-38
-> only latches with sleeps are shown
-> ordered by name, sleeps desc

                                                     NoWait              Waiter
Latch Name               Where                       Misses     Sleeps   Sleeps
------------------------ -------------------------- ------- ---------- --------
FOB s.o list latch       ksfd_allfob                      0          1        1
In memory undo latch     ktiFlush: child                  0          1        1
In memory undo latch     ktichg: child                    0          1        0
JS Sh mem access         jsksGetShMemLatch                0          1        1
active service list      kswslogon: session logout        0          3        3
cache buffers chains     kcbget: pin buffer               0          5        1
cache buffers chains     kcbgcur_2                        0          1        0
cache buffers chains     kcbget: exchange                 0          1        2
cache buffers chains     kcbgtcr: fast path               0          1        1
cache buffers chains     kcbgtcr: fast path (cr pin       0          1        0
cache buffers chains     kcbzib: exchange rls             0          1        3
cache buffers lru chain  kcbzgws                          0          1        0
call allocation          ksuxds                           0          1        1
client/application info  ksuinfos_act                     0          8        8
client/application info  ksuinfos_modact                  0          5        2
client/application info  kskirefrattrmap                  0          1        4
enqueue hash chains      ksqgtl3                          0         10       14
enqueue hash chains      ksqrcl                           0          8        4
object queue header oper kcbo_switch_cq                   0          1        0
process allocation       ksucrp:1                         0          1        0
redo allocation          kcrfw_redo_gen: redo alloc       0          1        0
row cache objects        kqreqd: reget                    0          5        0
shared pool              kghalo                           0          8        6
shared pool              kghupr1                          0          2        2
shared pool              kghfre                           0          1        1
          -------------------------------------------------------------

There is also a latch sleep breakdown report which provides some additional detail if a latch is being constantly moved into the sleep cycle, which can cause additional performance issues.

The latch miss sources report provides a list of latches that encountered sleep conditions. This report can be of further assistance when trying to analyze which latches are causing problems with your database.

Mutex Sleep Summary                           DB/Inst: ORCL/orcl  Snaps: 37-38
-> ordered by number of sleeps desc

                                                                         Wait
Mutex Type            Location                               Sleeps    Time (ms)
--------------------- -------------------------------- ------------ ------------
Library Cache         kglpnal1  90                               46           -0
Library Cache         kglpndl1  95                               29           -1
Library Cache         kglhdgn2 106                                9           -1
Library Cache         kglIsOwnerVersionable 121                   3            0
Library Cache         kglget2   2                                 3         -172
Library Cache         kgllkdl1  85                                3            4
Library Cache         kglobpn1  71                                3            0
Library Cache         kglhdgn1  62                                2           -4
Library Cache         kglpin1   4                                 2           -8
          -------------------------------------------------------------

Parent Latch Statistics                      DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Child Latch Statistics                        DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Segments Statistics Sections

This is a series of reports that let you identify objects that are heavily used. It contains several sub-sections like:

Segments by Logical Reads
Segments by Physical Reads
Segments by Physical Read Requests
Segments by UnOptimized Reads
Segments by Optimized Reads
Segments by Direct Physical Reads
Segments by Physical Writes
Segments by Physical Write Requests
Segments by Direct Physical Writes
Segments by Table Scans
Segments by DB Blocks Changes
Segments by Row Lock Waits
Segments by ITL Waits
Segments by Buffer Busy Waits

Segments by Logical Reads and Segments by Physical Reads

The "segments by logical reads" and "segments by physical reads" reports provide information on the database segments (tables, indexes) that are receiving the largest number of logical or physical reads. These reports can help you find objects that are "hot" objects in the database. You may want to review the objects and determine why they are hot, and if there are any tuning opportunities available on those objects (e.g. partitioning), or on SQL accessing those objects.

For example, if an object is showing up on the physical reads report, it may be that an index is needed on that object. Here is an example of the segments by logical reads report:

Segments by Logical Reads                    DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total Logical Reads:         731,220
-> Captured Segments account for   82.0% of Total

           Tablespace                      Subobject  Obj.       Logical
Owner         Name    Object Name            Name     Type         Reads  %Total
---------- ---------- -------------------- ---------- ----- ------------ -------
SOE        SOE        INVENTORY_PK                    INDEX      107,440   14.69
SOE        SOE        PRD_DESC_PK                     INDEX       57,200    7.82
SOE        SOE        INVENTORIES                     TABLE       48,512    6.63
SYS        SYSTEM     OPTSTAT_HIST_CONTROL            TABLE       42,736    5.84
SOE        SOE        PRODUCT_INFORMATION_            INDEX       36,800    5.03
          -------------------------------------------------------------

Segments by Physical Reads
Queries using these segments should be analyzed to check whether any FTS is happening on these segments. In case FTS is happening then proper indexes should be created to eliminate FTS.
Most of these SQLs can be found under section SQL Statistics -> SQL ordered by Reads.

Several segment related reports appear providing information on:
•Segments with ITL waits
•Segments with Row lock waits
•Segments with buffer busy waits
•Segments with global cache buffer waits
•Segments with CR Blocks received
•Segments with current blocks received

Segments by Physical Reads                    DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total Physical Reads:          47,336
-> Captured Segments account for   70.1% of Total

           Tablespace                      Subobject  Obj.      Physical
Owner         Name    Object Name            Name     Type         Reads  %Total
---------- ---------- -------------------- ---------- ----- ------------ -------
SOE        SOE        INVENTORIES                     TABLE        8,199   17.32
SOE        SOE        ITEM_PRODUCT_IX                 INDEX        5,024   10.61
SOE        SOE        CUSTOMERS_PK                    INDEX        3,928    8.30
SOE        SOE        ORD_WAREHOUSE_IX                INDEX        2,283    4.82
SOE        SOE        ITEM_ORDER_IX                   INDEX        2,228    4.71
          -------------------------------------------------------------

Segments by Physical Read Requests            DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total Physical Read Requests:          38,018
-> Captured Segments account for   83.8% of Total

           Tablespace                      Subobject  Obj.     Phys Read
Owner         Name    Object Name            Name     Type      Requests  %Total
---------- ---------- -------------------- ---------- ----- ------------ -------
SOE        SOE        INVENTORIES                     TABLE        8,199   21.57
SOE        SOE        ITEM_PRODUCT_IX                 INDEX        5,024   13.21
SOE        SOE        CUSTOMERS_PK                    INDEX        3,928   10.33
SOE        SOE        ORD_WAREHOUSE_IX                INDEX        2,283    6.01
SOE        SOE        ITEM_ORDER_IX                   INDEX        2,228    5.86
          -------------------------------------------------------------

Segments by UnOptimized Reads                 DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total UnOptimized Read Requests:          38,018
-> Captured Segments account for   83.8% of Total

           Tablespace                      Subobject  Obj.   UnOptimized
Owner         Name    Object Name            Name     Type         Reads  %Total
---------- ---------- -------------------- ---------- ----- ------------ -------
SOE        SOE        INVENTORIES                     TABLE        8,199   21.57
SOE        SOE        ITEM_PRODUCT_IX                 INDEX        5,024   13.21
SOE        SOE        CUSTOMERS_PK                    INDEX        3,928   10.33
SOE        SOE        ORD_WAREHOUSE_IX                INDEX        2,283    6.01
SOE        SOE        ITEM_ORDER_IX                   INDEX        2,228    5.86
          -------------------------------------------------------------

Segments by Optimized Reads                   DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Segments by Direct Physical Reads             DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Segments by Physical Writes                   DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total Physical Writes:          14,720
-> Captured Segments account for   82.0% of Total

           Tablespace                      Subobject  Obj.      Physical
Owner         Name    Object Name            Name     Type        Writes  %Total
---------- ---------- -------------------- ---------- ----- ------------ -------
SOE        SOE        ITEM_PRODUCT_IX                 INDEX        3,015   20.48
SOE        SOE        ORD_WAREHOUSE_IX                INDEX        1,363    9.26
SOE        SOE        ORDER_PK                        INDEX        1,339    9.10
** UNAVAIL ** UNAVAIL ** UNAVAILABLE **    AILABLE ** UNDEF        1,162    7.89
SOE        SOE        INVENTORIES                     TABLE        1,157    7.86
          -------------------------------------------------------------

Segments by Physical Write Requests           DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total Physical Write Requestss:           9,495
-> Captured Segments account for   86.7% of Total

           Tablespace                      Subobject  Obj.    Phys Write
Owner         Name    Object Name            Name     Type      Requests  %Total
---------- ---------- -------------------- ---------- ----- ------------ -------
SOE        SOE        ITEM_PRODUCT_IX                 INDEX        2,441   25.71
SOE        SOE        ITEM_ORDER_IX                   INDEX        1,141   12.02
SOE        SOE        ORDER_ITEMS_PK                  INDEX        1,133   11.93
SOE        SOE        ORD_WAREHOUSE_IX                INDEX          986   10.38
** UNAVAIL ** UNAVAIL ** UNAVAILABLE **    AILABLE ** UNDEF          975   10.27
          -------------------------------------------------------------

Segments by Direct Physical Writes            DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total Direct Physical Writes:              38
-> Captured Segments account for   97.4% of Total

           Tablespace                      Subobject  Obj.        Direct
Owner         Name    Object Name            Name     Type        Writes  %Total
---------- ---------- -------------------- ---------- ----- ------------ -------
SYS        SYSAUX     WRH$_ACTIVE_SESSION_ 4731332_34 TABLE           37   97.37
          -------------------------------------------------------------

Segments by Table Scans                       DB/Inst: ORCL/orcl  Snaps: 37-38
-> Total Table Scans:               9
-> Captured Segments account for   44.4% of Total

           Tablespace                      Subobject  Obj.         Table
Owner         Name    Object Name            Name     Type         Scans  %Total
---------- ---------- -------------------- ---------- ----- ------------ -------
SYS        SYSTEM     I_OBJ2                          INDEX            3   33.33
SYS        SYSAUX     WRH$_SEG_STAT_PK     4731332_34 INDEX            1   11.11
          -------------------------------------------------------------

Segments by DB Blocks Changes                 DB/Inst: ORCL/orcl  Snaps: 37-38
-> % of Capture shows % of DB Block Changes for each top segment compared
-> with total DB Block Changes for all segments captured by the Snapshot

           Tablespace                      Subobject  Obj.      DB Block    % of
Owner         Name    Object Name            Name     Type       Changes Capture
---------- ---------- -------------------- ---------- ----- ------------ -------
SOE        SOE        ORD_WAREHOUSE_IX                INDEX        4,848   25.40
SOE        SOE        INVENTORIES                     TABLE        2,832   14.84
SOE        SOE        ITEM_ORDER_IX                   INDEX        2,544   13.33
SOE        SOE        ITEM_PRODUCT_IX                 INDEX        2,416   12.66
SOE        SOE        ORDER_ITEMS_PK                  INDEX        1,984   10.39
          -------------------------------------------------------------
          
Segments by Row Lock Waits                   DB/Inst: ORCL/orcl  Snaps: 37-38
-> % of Capture shows % of row lock waits for each top segment compared
-> with total row lock waits for all segments captured by the Snapshot

                                                                     Row
           Tablespace                      Subobject  Obj.          Lock    % of
Owner         Name    Object Name            Name     Type         Waits Capture
---------- ---------- -------------------- ---------- ----- ------------ -------
SOE        SOE        CUST_ACCOUNT_MANAGER            INDEX           13   61.90
SOE        SOE        ORD_ORDER_DATE_IX               INDEX            8   38.10
          -------------------------------------------------------------

The statistic displays segment details based on total “Row lock waits” which happened during snapshot period. Data displayed is sorted on “Row Lock Waits” column in descending order. It provides information about segments for which more database locking is happening.

DML statements using these segments should be analysed further to check the possibility of reducing concurrency due to row locking.

Segments by ITL Waits                         DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Whenver a transaction modifies segment block, it first add transaction id in the Internal Transaction List table of the block. Size of this table is a block level configurable parameter. Based on the value of this parameter those many ITL slots are created in each block.

ITL wait happens in case total trasactions trying to update same block at the same time are greater than the ITL parameter value.

Total waits happening in the example are very less, 23 is the Max one. Hence it is not recommended to increase the ITL parameter value.

Buffer busy waits happen when more than one transaction tries to access same block at the same time. In this scenario, the first transaction which acquires lock on the block will able to proceed further whereas other transaction waits for the first transaction to finish.

If there are more than one instances of a process continuously polling database by executing same SQL (to check if there are any records available for processing), same block is read concurrently by all the instances of a process and this result in Buffer Busy wait event.

Segments by Buffer Busy Waits                 DB/Inst: ORCL/orcl  Snaps: 37-38
-> % of Capture shows % of Buffer Busy Waits for each top segment compared
-> with total Buffer Busy Waits for all segments captured by the Snapshot

                                                                  Buffer
           Tablespace                      Subobject  Obj.          Busy    % of
Owner         Name    Object Name            Name     Type         Waits Capture
---------- ---------- -------------------- ---------- ----- ------------ -------
SYS        SYSTEM     AUD$                            TABLE           10  100.00
          -------------------------------------------------------------

Dictionary Cache Stats                       DB/Inst: ORCL/orcl  Snaps: 37-38
-> "Pct Misses"  should be very low (< 2% in most cases)
-> "Final Usage" is the number of cache entries being used

                                   Get    Pct    Scan   Pct      Mod      Final
Cache                         Requests   Miss    Reqs  Miss     Reqs      Usage
------------------------- ------------ ------ ------- ----- -------- ----------
dc_awr_control                      11    0.0       0   N/A        2          1
dc_global_oids                      61    9.8       0   N/A        0         40
dc_histogram_data                5,195    3.5       0   N/A        0      1,481
dc_histogram_defs                6,648    6.2       0   N/A        7      3,397
dc_object_grants                    34   11.8       0   N/A        0         17
dc_objects                       7,387    2.6       0   N/A       17      1,027
dc_profiles                         83    0.0       0   N/A        0          1
dc_rollback_segments               639    0.3       0   N/A       24         34
dc_segments                      1,108    7.2       0   N/A       18        558
dc_sequences                        12   16.7       0   N/A       12          5
dc_tablespaces                  44,263    0.0       0   N/A        0          8
dc_users                        46,513    0.0       0   N/A        0        122
global database name               325    0.0       0   N/A        0          1
outstanding_alerts                   5    0.0       0   N/A        0          5
sch_lj_objs                          8   25.0       0   N/A        0          2
sch_lj_oids                          4   50.0       0   N/A        0          4
          -------------------------------------------------------------

Library Cache Activity                        DB/Inst: ORCL/orcl  Snaps: 37-38
-> "Pct Misses"  should be very low

                         Get    Pct            Pin    Pct             Invali-
Namespace           Requests   Miss       Requests   Miss    Reloads  dations
--------------- ------------ ------ -------------- ------ ---------- --------
BODY                     542    1.8         33,250    0.0          1        0
CLUSTER                  256    0.4             76    1.3          0        0
DBLINK                   161    0.0              0    N/A          0        0
EDITION                   87    0.0            168    0.0          0        0
INDEX                     43    7.0             44    9.1          0        0
OBJECT ID                  3  100.0              0    N/A          0        0
SCHEMA                   437    1.1              0    N/A          0        0
SQL AREA               3,489   28.9        101,974    0.8        120        8
TABLE/PROCEDURE        4,040    3.4         39,880    1.1        258        0
TRIGGER                   10   50.0             10   50.0          0        0
          -------------------------------------------------------------

Memory Dynamic Components                    DB/Inst: ORCL/orcl  Snaps: 37-38
-> Min/Max sizes since instance startup
-> Oper Types/Modes: INItializing,GROw,SHRink,STAtic/IMMediate,DEFerred
-> ordered by Component

                 Begin Snap     Current         Min         Max   Oper Last Op
Component         Size (Mb)   Size (Mb)   Size (Mb)   Size (Mb)  Count Typ/Mod
--------------- ----------- ----------- ----------- ----------- ------ -------
ASM Buffer Cach         .00         .00         .00         .00      0 STA/
DEFAULT 16K buf         .00         .00         .00         .00      0 STA/
DEFAULT 2K buff         .00         .00         .00         .00      0 STA/
DEFAULT 32K buf         .00         .00         .00         .00      0 STA/
DEFAULT 4K buff         .00         .00         .00         .00      0 STA/
DEFAULT 8K buff         .00         .00         .00         .00      0 STA/
DEFAULT buffer       424.00      424.00      424.00      460.00      0 SHR/DEF
KEEP buffer cac      100.00      100.00      100.00      100.00      0 INI/
PGA Target           268.00      268.00      268.00      268.00      0 STA/
RECYCLE buffer          .00         .00         .00         .00      0 STA/
SGA Target           756.00      756.00      756.00      756.00      0 STA/
Shared IO Pool          .00         .00         .00         .00      0 STA/
java pool              4.00        4.00        4.00        4.00      0 STA/
large pool             4.00        4.00        4.00        4.00      0 STA/
shared pool          212.00      212.00      176.00      212.00      0 GRO/DEF
streams pool            .00         .00         .00         .00      0 STA/
          -------------------------------------------------------------

Memory Resize Operations Summary              DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Memory Resize Ops                             DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Process Memory Summary                       DB/Inst: ORCL/orcl  Snaps: 37-38
-> B: Begin Snap   E: End Snap
-> All rows below contain absolute values (i.e. not diffed over the interval)
-> Max Alloc is Maximum PGA Allocation size at snapshot time
-> Hist Max Alloc is the Historical Max Allocation for still-connected processes
-> ordered by Begin/End snapshot, Alloc (MB) desc

                                                            Hist
                                    Avg  Std Dev     Max     Max
               Alloc      Used    Alloc    Alloc   Alloc   Alloc    Num    Num
  Category      (MB)      (MB)     (MB)     (MB)    (MB)    (MB)   Proc  Alloc
- -------- --------- --------- -------- -------- ------- ------- ------ ------
B Other         46.4       N/A      1.7      2.3      11      11     27     27
  Freeable      12.6        .0      1.6      1.5       5     N/A      8      8
  SQL            1.0        .8       .1       .2       1      21     13      9
  PL/SQL          .6        .5       .0       .1       0       0     25     25
E Other         83.0       N/A      2.9      6.4      34      34     29     29
  Freeable      18.1        .0      1.8      2.3       7     N/A     10     10
  PL/SQL         2.7       2.6       .1       .3       1       1     27     27
  SQL            1.3       1.0       .1       .2       1      21     15     11
          -------------------------------------------------------------

SGA Memory Summary                            DB/Inst: ORCL/orcl  Snaps: 37-38

                                                      End Size (Bytes)
SGA regions                     Begin Size (Bytes)      (if different)
------------------------------ ------------------- -------------------
Database Buffers                       549,453,824
Fixed Size                               2,220,200
Redo Buffers                             5,554,176
Variable Size                          511,709,016
                               -------------------
sum                                  1,068,937,216
          -------------------------------------------------------------

SGA breakdown difference                      DB/Inst: ORCL/orcl  Snaps: 37-38
-> ordered by Pool, Name
-> N/A value for Begin MB or End MB indicates the size of that Pool/Name was
   insignificant, or zero in that snapshot

Pool   Name                                 Begin MB         End MB  % Diff
------ ------------------------------ -------------- -------------- -------
java   free memory                               4.0            4.0    0.00
large  PX msg pool                               3.7            3.7    0.00
large  free memory                                .3             .3    0.00
shared ASH buffers                               4.0            4.0    0.00
shared CCUR                                      8.7            9.0    3.71
shared FileOpenBlock                             3.8            3.8    0.00
shared KCB Table Scan Buffer                     3.8            3.8    0.00
shared KGLH0                                     3.3            3.9   17.30
shared KGLHD                                     3.4            4.1   19.28
shared KGLS                                      4.8            6.7   39.12
shared KGLSG                                     5.0            5.0    0.00
shared KSFD SGA I/O b                            3.8            3.8    0.00
shared PCUR                                      5.0            5.6   12.90
shared PLDIA                                     N/A            2.1     N/A
shared PLMCD                                     4.8            6.7   39.15
shared SQLA                                     52.3           50.1   -4.30
shared db_block_hash_buckets                     5.6            5.6    0.00
shared dbktb: trace buffer                       2.3            2.3    0.00
shared dbwriter coalesce buffer                  3.8            3.8    0.00
shared event statistics per sess                 3.0            3.0    0.00
shared free memory                              32.9           27.4  -16.69
shared kglsim hash table bkts                    4.0            4.0    0.00
shared ksunfy : SSO free list                    2.8            2.8    0.00
shared obj stats allocation chun                 2.5            2.5    0.00
shared private strands                           3.5            3.5    0.00
shared row cache                                 7.2            7.2    0.00
shared write state object                        2.8            2.8    0.00
       buffer_cache                            524.0          524.0    0.00
       fixed_sga                                 2.1            2.1    0.00
       log_buffer                                5.3            5.3    0.00
          -------------------------------------------------------------

Streams CPU/IO Usage                         DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Streams Capture                               DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Streams Capture Rate                          DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Streams Apply                                 DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Streams Apply Rate                            DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Buffered Queues                               DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Buffered Queue Subscribers                    DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Rule Set                                      DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Persistent Queues                             DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Persistent Queues Rate                        DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Persistent Queue Subscribers                  DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Resource Limit Stats                             DB/Inst: ORCL/orcl  Snap: 38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Shared Servers Activity                       DB/Inst: ORCL/orcl  Snaps: 37-38
-> Values represent averages for all samples

   Avg Total   Avg Active    Avg Total   Avg Active    Avg Total   Avg Active
 Connections  Connections Shared Srvrs Shared Srvrs  Dispatchers  Dispatchers
------------ ------------ ------------ ------------ ------------ ------------
           0            0            1            0            1            0
          -------------------------------------------------------------

Shared Servers Rates                          DB/Inst: ORCL/orcl  Snaps: 37-38

  Common     Disp                        Common       Disp     Server
   Queue    Queue   Server    Server      Queue      Queue      Total     Server
 Per Sec  Per Sec Msgs/Sec    KB/Sec      Total      Total       Msgs  Total(KB)
-------- -------- -------- --------- ---------- ---------- ---------- ----------
       0        0        0       0.0          0          0          0          0
          -------------------------------------------------------------

Shared Servers Utilization                    DB/Inst: ORCL/orcl  Snaps: 37-38
-> Statistics are combined for all servers
-> Incoming and Outgoing Net % are included in %Busy

  Total Server                    Incoming  Outgoing
      Time (s)    %Busy    %Idle     Net %     Net %
-------------- -------- -------- --------- ---------
           372      0.0    100.0       0.0       0.0
          -------------------------------------------------------------

Shared Servers Common Queue                   DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

Shared Servers Dispatchers                    DB/Inst: ORCL/orcl  Snaps: 37-38
-> Ordered by %Busy, descending
-> Total Queued, Total Queue Wait and Avg Queue Wait are for dispatcher queue
-> Name suffixes:
     "(N)" - dispatcher started between begin and end snapshots
     "(R)" - dispatcher re-started between begin and end snapshots

              Avg Total Disp                        Total Total Queue  Avg Queue
Name        Conns   Time (s)    %Busy    %Idle     Queued    Wait (s)  Wait (ms)
------- --------- ---------- -------- -------- ---------- ----------- ----------
D000          0.0        372      0.0    100.0          0           0
          -------------------------------------------------------------

init.ora Parameters                          DB/Inst: ORCL/orcl  Snaps: 37-38
-> if IP/Public/Source at End snap is different a '*' is displayed

                                                                End value
Parameter Name                Begin value                       (if different)
----------------------------- --------------------------------- --------------
audit_file_dest               /home/oracle/app/oracle/admin/orc
audit_trail                   DB
compatible                    11.2.0.0.0
control_files                 /home/oracle/app/oracle/oradata/o
db_block_size                 8192
db_domain
db_keep_cache_size            104857600
db_name                       orcl
diagnostic_dest               /home/oracle/app/oracle
dispatchers                   (PROTOCOL=TCP) (SERVICE=orclXDB)
memory_max_target             1585446912
memory_target                 1073741824
open_cursors                  300
pga_aggregate_target          268435456
processes                     150
remote_login_passwordfile     EXCLUSIVE
sga_max_size                  1073741824
sga_target                    792723456
undo_tablespace               UNDOTBS1
          -------------------------------------------------------------

Dynamic Remastering Stats                     DB/Inst: ORCL/orcl  Snaps: 37-38

                  No data exists for this section of the report.
          -------------------------------------------------------------

End of Report

Retrieve SQL and Execution Plan from AWR Snapshots
This is a simple script that can help you to collect SQL statements executed since yesterday (configurable) that contains a specific value in its sentence.

col parsed format a6
col sql_text format a40
set lines 200
set pages 300
select sql_text, parsing_schema_name as parsed, elapsed_time_delta/1000/1000 as elapsed_sec, stat.snap_id,
       to_char(snap.end_interval_time,'dd.mm hh24:mi:ss') as snaptime, txt.sql_id
from dba_hist_sqlstat stat, dba_hist_sqltext txt, dba_hist_snapshot snap
where stat.sql_id=txt.sql_id
  and stat.snap_id=snap.snap_id
  and snap.begin_interval_time >= sysdate-1
  and lower(sql_text) like '%&sql_test%'
  and parsing_schema_name not in ('SYS','SYSMAN','MDSYS','WKSYS')
order by elapsed_time_delta asc;

This will show something like:
Enter value for sql_test: delete
old   7:   and lower(sql_text) like '%&sql_test%'
new   7:   and lower(sql_text) like '%delete%'
SQL_TEXT                                 PARSED ELAPSED_SEC    SNAP_ID SNAPTIME
      SQL_ID
---------------------------------------- ------ ----------- ---------- ---------
----- -------------
DELETE FROM WWV_FLOW_FILE_OBJECTS$ WHERE APEX_0     .484942        688 23.08 16:
00:54 8rpn8jtjnuu73
 SECURITY_GROUP_ID = 0                   30200

Then with that sql_id, we can retrieve the execution plan from the snapshots:
select plan_table_output from table (dbms_xplan.display_awr('&sqlid'));

Enter value for sqlid: 8rpn8jtjnuu73
old   1: select plan_table_output from table (dbms_xplan.display_awr('&sqlid'))
new   1: select plan_table_output from table (dbms_xplan.display_awr('8rpn8jtjnuu73'))

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------

SQL_ID 8rpn8jtjnuu73
--------------------
DELETE FROM WWV_FLOW_FILE_OBJECTS$ WHERE SECURITY_GROUP_ID = 0
Plan hash value: 358826532

-------------------------------------------------------------------------------------
| Id  | Operation         | Name                       | Rows  | Bytes | Cost (%CPU)|
-------------------------------------------------------------------------------------
|   0 | DELETE STATEMENT  |                            |       |       |     1 (100)|
|   1 |  DELETE           | WWV_FLOW_FILE_OBJECTS$     |       |       |            |
|   2 |   INDEX RANGE SCAN| WWV_FLOW_FILES_SGID_FK_IDX |     1 |   202 |     0   (0)|
-------------------------------------------------------------------------------------


Get Data from ASH
If you need to quickly check a performance problem on your DB, ASH is great here
We sample the Wait-Events of active sessions every second into the ASH-Buffer.
It is accessed most comfortable with the Enterprise Manager GUI from the Performance Page (Button ASH Report there).
Or with little effort from the command line like this:

-----------------------------------------
-- Top 10 CPU consumers in last 5 minutes
-----------------------------------------
select *
from (select session_id, session_serial#, count(*)
         from v$active_session_history
         where session_state= 'ON CPU'
           and sample_time > sysdate - interval '5' minute
         group by session_id, session_serial#
         order by count(*) desc
     )
where rownum <= 10;


--------------------------------------------
-- Top 10 waiting sessions in last 5 minutes
--------------------------------------------
select *
from (select session_id, session_serial#,count(*)
        from v$active_session_history
        where session_state='WAITING'
          and sample_time >  sysdate - interval '5' minute
        group by session_id, session_serial#
        order by count(*) desc
      )
where rownum <= 10;


-- These 2 queries should spot the most incriminating sessions of the last 5 minutes.
-- But who is that and what SQL was running?


--------------------
-- Who is that SID?
--------------------
set lines 200
col username for a10
col osuser for a10
col machine for a10
col program for a10
col resource_consumer_group for a10
col client_info for a10

select  serial#, username, osuser, machine, program, resource_consumer_group, client_info
from v$session
where sid = &sid;


-------------------------
-- What did that SID do?
-------------------------
select distinct sql_id, session_serial#
from v$active_session_history
where sample_time >  sysdate - interval '5' minute
and session_id = &sid;


----------------------------------------------
-- Retrieve the SQL from the Library Cache:
----------------------------------------------
col sql_text for a80
select sql_text from v$sql where sql_id='&sqlid';


Moving AWR information
Enterprise Manager allows administrators to transfer Automatic Workload Repository snapshots to other workload repositories for offline analysis. This is accomplished by the administrator specifying a snapshot range and extracting the AWR data to a flat file. The flat file is then loaded into a user-specified staging schema in the target repository. To complete the transfer, the data is copied from the staging schema into the target repository's SYS schema. The data in the SYS schema is then used as the source for the ADDM analysis.
If the snapshot range already exists in the SYS or staging schemas, the data being imported is ignored. All data in snapshot ranges that does not conflict with existing data is loaded. Oracle contains a new package DBMS_SWRF_INTERNAL to provide AWR snapshot export and import functionality.
The example below exports a snapshot range starting with 100 and ending at 105 to the output dump file 'awr_wmprod1_101_105' in the directory '/opt/oracle/admin/awrdump/wmprod1':
BEGIN
DBMS_SWR_INTERNAL.AWR_EXTRACT(
DMPFILE =>'awr_export_wmprod1_101_105',
DMPDIR => '/opt/oracle/admin/awrdump/wmprod1',
BID => 101,
EID => 105)

We then use the AWR_LOAD procedure to load the data into our target repository staging schema:
BEGIN
DBMS_SWR_INTERNAL.AWR_LOAD(
SCHNAME => 'foot',
DMPFILE =>'awr_export_wmprod1_101_105',
DMPDIR => '/opt/oracle/admin/awrdump/wmprod1')
The last step is to transfer the data from our staging schema (FOOT) to the SYS schema for analysis:
BEGIN
DBMS_SWR_INTERNAL.MOVE_TO_AWR(SCHNAME => 'foot',)


Links with AWR Analyzer
Excel Performance Analyzer (Perfsheet v2.0)
http://www.oraperf.com 
http://www.txmemsys.com/statspack-reg.htm (Statspack Analyzer)
http://www.dbapool.com/dbanalyzer.php (Analyze your AWR or Statspack)
http://www.softpedia.com/get/Internet/Servers/Database-Utils/spReporter.shtml  (Download Tool to Analyze AWR or Statspack Reports)
http://www.ondatafine.com/  (web based application. It processes plain-text statspack or AWR)
http://www.spviewer.com/index.html (STATSPACK and AWR Viewer software)
Scripts: http://www.evdbt.com/tools.htm

-- INFORMAÇÕES RETIRADAS DE http://pafumi.net/AWR%20Reports.html#Introduction